% $Author$
% $Date$
% $Revision$
%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.815in,.815in},
		vmargin={.98in,.98in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	\renewcommand{\nnbb}[2]{} % Disable editorial comments
\fi
%=================================================================
\chapter{Morphic}

%\sd{We should first give a conceptual overview.
%Then we need a cookbook of how to do simple things in Morphic.
%The observer pattern and its implementation with changed:  and update: messages could go here.  Or in ``Idiomatic design patterns'' later.}

\indmain{Morphic} is the name given to \sq's graphical interface.
Morphic is written in \st, so it is fully portable between operating systems; as a consequence, \sq looks exactly the same on Unix, macOS, and Windows.
What distinguishes Morphic from most other user interface toolkits is that it does not have separate modes for ``composing'' and ``running'' the interface:
All the graphical elements can be assembled and disassembled by the user, at any time.%
\footnote{We thank Hilaire Fernandes for permission to base this chapter on his original article in French.}

\ab{After the first printing, I took an editing pass, correcting some errors and grammatical infelicities.}

\on{I have commented out the LabelstickerMorph and PyramidMorph examples, as they do not really add much over the other examples we have already. The source code is now available in the example subdirectory, in case someone would like to try and use them after all.}

%=================================================================
\section{The history of Morphic}

Morphic was developed by John Maloney and Randy Smith for the \ind{Self} programming language, starting around 1993.
Maloney later wrote a new version of Morphic for \sq, but the basic ideas behind the Self version are still alive and well in \sq Morphic: \emph{directness} and \emph{liveness}.
Directness means that the shapes on the screen are objects that can be examined or changed directly, that is, by pointing at them using the mouse.
Liveness means that the user interface is always able to respond to user actions:
Information on the screen is continuously updated as the world that it describes changes.
A simple example of this is that you can detach a menu item and keep it as a button.

\dothis{Bring up the world menu.
	Blue-click once on the world menu to bring up its morphic halo, then blue-click again on the menu item you want to detach to bring up its halo.
	Now drag that item elsewhere on the screen by grabbing the black handle \grabHandle, as shown in \figref{detachingMenu}.}
\index{Morphic!halo}
\index{blue button}

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: 'figures/detachingMenu.png' frame: [:bounds | bounds * ((0 to: 1) rect: (0.457 to: 0.748))] building: [:helper |
	| item halo handle |
	helper click: helper world.
	helper closeBalloons.
	item := helper menuItemMorphLabeled: 'new morph*' in: helper menu.
	helper select: helper menu at: item contents.
	halo := helper mouseOpenHaloFor: item.
	handle := halo handles at: #doGrab:with:.
	helper
		mouseDrag: handle
			from: handle center
			to: handle center + (-100 @ 15)
			buttons: #(left);
		spawnHand
]
\end{ExecuteSmalltalkScript}
\begin{figure}[ht]
	\ifluluelse
		{\centerline{\includegraphics[width=0.6\textwidth]{detachingMenu}}}
		{\centerline{\includegraphics[width=0.4\textwidth]{detachingMenu}}}
	\caption{Detaching a morph, here the \menu{new morph} menu item, to make it an independent button.
		\label{fig:detachingMenu}}
\end{figure}

All of the objects that you see on the screen when you run \sq are \emph{Morphs}, that is, they are instances of subclasses of class \ct{Morph}.
\mbox{\ct{Morph}} itself is a large class with many methods; this makes it possible for subclasses to implement interesting behavior with little code.
You can create a morph to represent any object, although how good a representation you get depends on whether the creators of the class of the object provided the necessary methods.

\dothis{To create a morph to represent a string object, execute the following code in a workspace, one line at a time.}
\begin{code}{}
s := 'Morph' asMorph openInWorld.
s explore.
\end{code}
\cmindex{Morph}{openInWorld}

The first line creates a Morph to represent the string \ct{'Morph'}, and then opens it (that is, displays it) in the ``world'', which is the name that \sq gives to the screen.
You should obtain a graphical element\,---\,a Morph\,---\,which you can manipulate by blue-clicking.
The second line opens an explorer that shows you attributes of this Morph, such as its \ct{fullBounds} and \ct{color}.
%TODO: This is currently not working, readd as soon as this is fixed
%The second line opens a ``viewer'' that shows you attributes of this Morph, such as its \ct{x} and \ct{y} coordinates on the screen.
%Clicking on one of the yellow exclamation marks sends a message to the Morph which then responds appropriately.

Of course, it is possible to define morphs that are more interesting graphical representations than the one that you have just seen.
The method \mthind{Object}{asMorph} has a default implementation in class \ct{Object} class that just creates a \ct{StringMorph}.
For many objects, that is not a very useful graphical representation and thus the override it with a more interesting mapping.

\dothis{Open a browser on the \ct{Color} class and browse the following method.}

\needlines{6}
\begin{method}{Getting a morph for an instance of \ct{Color}.}
Color>>>asMorph

	^ (RectangleMorph new)
		fillStyle: self;
		borderWidth: 0;
		yourself
\end{method}
\noindent

When you try this method by executing \ct{Color orange asMorph} \mthind{Morph}{openInWorld} in a workspace, you get an orange rectangle, instead of a plain \ct{StringMorph}!

%=================================================================
\section{Manipulating morphs}

Morphs are objects, so we can manipulate them like any other object in \st:
By sending messages, we can change their properties, create new subclasses of Morph, and so on.

Every morph, even if it is not currently open on the screen, has a position and a size.
For convenience, all morphs are considered to occupy a rectangular region of the screen; if they are irregularly shaped, their position and size are those of the smallest rectangular ``box'' that surrounds them, which is known as the morph's bounding box, or just its ``bounds''.
The \mthind{Morph}{position} method returns a \ct{Point} that describes the location of the morph's upper left corner (which is also the upper left corner of its bounding box).
The origin of the coordinate system is the screen's upper left corner, with $y$ coordinates increasing \emph{down} the screen and $x$ coordinates increasing to the \emph{right}.
The \ct{extent} method also returns a point, but this point specifies the width and height of the morph rather than a location.

\dothis{Type the following code into a workspace and \menu{do it}:}
\begin{code}{}
joe := Morph new color: Color blue.
joe openInWorld.
bill := Morph new color: Color red .
bill openInWorld.
\end{code}
\noindent
Then type \ct{joe position} and \menu{print it}.
To move joe, execute \ct{joe position: joe position + (10 @ 3)} repeatedly.

It is possible to do a similar thing with size.
\ct{joe} \mthind{Morph}{extent} answers joe's size; to have joe grow, execute \ct{joe extent: joe extent * 1.1}.
To change the color of a morph, send it the \mthind{Morph}{color:} message with the desired \ct{Color} object as argument, for instance, \ct{joe color: Color orange}.
To add transparency, try \ct{joe color: (Color orange alpha: 0.5)}.

\dothis{To make bill follow joe, you can repeatedly execute this code:}
\begin{code}{}
bill position: joe position + (100 @ 0).
\end{code}
\noindent
If you move joe using the mouse and then execute this code, bill will move so that it is 100 pixels to the right of joe.
% It would seem that this would be a good place to introduce the \ct{step} method

%=================================================================
\section{Composing morphs}

One way of creating new graphical representations is by placing one morph inside another.
This is called \emph{composition}; morphs can be composed to any depth.
%
%To create new morphs, there are two main techniques that you can combine:
%\begin{enumerate}
%	\item by composing morphs one into another,
%	\item by subclassing \ct{Morph} and overriding \mthind{Morph}{drawOn:} to draw original morph shapes.
%\end{enumerate}
%}
\index{Morph!composing}
You can place a morph inside another by sending the message \mthind{Morph}{addMorph:} to the container morph.

\dothis{Try adding a morph to another one:}
\begin{code}{}
star := StarMorph new color: Color yellow.
joe addMorph: star.
star position: joe position.
\end{code}

\noindent
The last line positions the star at the same coordinates as joe.
Notice that the coordinates of the contained morph are still relative to the screen, not to the containing morph.
There are many  methods available to position a morph; browse the \protind{geometry} protocol of class \ct{Morph} to see for yourself.
For example, to center the star inside joe, execute \ct{star} \mthind{Morph}{center:} \ct{joe center}.

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: 'figures/joeStar.png' building: [:helper |
	| bill joe star |
	bill := Morph new color: Color red .
	bill openInWorld.
	joe := Morph new color: (Color blue alpha: 0.5).
	joe extent: 55@60.
	joe openInWorld.
	bill position: joe position - (27@20).
	star := StarMorph new color: Color yellow.
	joe addMorph: star.
	star center: joe center.
	helper centerAllMorphs.
]
\end{ExecuteSmalltalkScript}
\begin{figure}[ht]
	\centerline{\includegraphics{joeStar}}
	\caption{The star is contained inside joe, the translucent blue morph.
		\label{fig:joeStar}}
\end{figure}

If you now try to grab the star with the mouse, you will find that you actually grab joe, and the two morphs move together:
The star is \emph{embedded} inside joe.
It is possible to embed more morphs inside joe.
In addition to doing this programmatically, you can also embed morphs by direct manipulation.

\dothis{From the world menu select ``objects'' and click on the button labeled ``Graphics''.
	% If you don't have a \menu{Supplies} flap at the bottom of your screen, execute \ct{Flaps enableGlobalFlaps} to create one.
	% ct TODO DISCUSS: We should uncomment the above line.
	Drag an ellipse and a star from the \menu{Supplies} flap.
	Place the star over the ellipse, and yellow-click the star to bring up a menu\footnote{You can also blue-click the star to bring up the morphic halo, and then click the red menu handle.}.
	Select \menu{embed into \go Ellipse}.
	Now the star and the ellipse move together.}

%\dothis{If you don't have a \menu{Supplies} flap at the bottom of your screen, execute \ct{Flaps enableGlobalFlaps} to create one.  Drag a yellow ellipse and a white star from the \menu{Supplies} flap.  Place the star over the ellipse, and yellow-click the star to bring up a menu\footnote{You can also blue-click the star to bring up the morphic halo, and then click the red menu handle.}.   Select \menu{embed into \go Ellipse}.  Now the star and the ellipse move together.}

To remove a sub-morph, do \ct{joe} \mthind{Morph}{removeMorph:} \ct{star} or \ct{star} \mthind{Morph}{delete}.
This can also be done by direct manipulation:

\dothis{Blue click twice on the star.
	Drag the star away from the ellipse using the grab handle \grabHandle{}.}

\noindent
The first click brings up the morphic halo on the ellipse; the second click the halo on the star.
Each click moves the focus down one level of embedding.


%=================================================================
\section{Creating and drawing your own morphs}

While it is possible to make many interesting and useful graphical representations by composing morphs, sometimes you will need to create something completely different.
\index{Morph!subclassing}
To do this you define a subclass of \ct{Morph} and override the \mthind{Morph}{drawOn:} method to change its appearance.

The morphic framework sends the message \ct{drawOn:} to a morph when it needs to redisplay the morph on the screen.
The parameter to \ct{drawOn:} is a kind of \clsind{Canvas}; the expected behavior is that the morph will draw itself on that canvas, inside its bounds.
Let's use this knowledge to create a cross-shaped morph.
\index{Morph!subclassing}

\dothis{Using the class browser, define a new class \clsind{SBECrossMorph} inheriting from \ct{Morph}:}
\begin{classdef}{Defining \ct{SBECrossMorph}.}
Morph subclass: #SBECrossMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SBE-Morphic'
\end{classdef}

We can define the \ct{drawOn:} method like this:

%The page break in this listing is fine, there is no better layouting option here --pre
\begin{method}[firstDrawOn]{Drawing a \ct{SBECrossMorph}.}
drawOn: aCanvas

	| crossHeight crossWidth horizontalBar verticalBar |
	crossHeight := self height / 3.0 .
	crossWidth := self width / 3.0 .
	horizontalBar := self bounds insetBy: 0@crossHeight.
	verticalBar := self bounds insetBy: crossWidth@0.
	aCanvas fillRectangle: horizontalBar color: self color.
	aCanvas fillRectangle: verticalBar color: self color.
\end{method}


\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeInto: 'figures' recordSeries: [:recorder :helper |
	thisContext wrap: [:block | helper restoreMethods: SBECrossMorph methodDict values after: block].
	SBECrossMorph removeSelector: #step.
	recorder writeTo: 'NewCross.png' building: [
		| cross |
		cross := SBECrossMorph new
			extent: 123 asPoint;
			openInWorld.
		helper centerAllMorphs.
		cross addHalo
	].
	helper world removeAllMorphs.
	recorder writeTo: 'overdrawBug.png' building: [
		| cross |
		SBECrossMorph compile: 'drawOn: aCanvas
	aCanvas fillRectangle: self horizontalBar color: self color.
	aCanvas fillRectangle: self verticalBar color: self color'
		.
		cross := SBECrossMorph newBounds: (0 @ 0 corner: 160 @ 160).
		cross openInWorld.
		cross color: (Color blue alpha: 0.3).
		helper centerAllMorphs.
	].
	recorder writeTo: 'hairlineBug.png' building: [
		SBECrossMorph
			compile: 'drawOn: aCanvas
	| topAndBottom |
	aCanvas fillRectangle: self horizontalBar color: self color.
	topAndBottom := self verticalBar areasOutside: (self horizontalBar in: [:bar |
		self flag: #hacked.
		bar withHeight: bar height + 1]).
	topAndBottom do: [ :each | aCanvas fillRectangle: each color: self color]'
			.
	]
]
\end{ExecuteSmalltalkScript}
\begin{figure}[hbt]
	\ifluluelse
		{\centerline{\includegraphics[width=0.3\textwidth]{NewCross}}}
		{\centerline{\includegraphics{NewCross}}}
	\caption{A \ct{SBECrossMorph} with its halo; you can resize it as you wish.
		\label{fig:cross}}
\end{figure}


Sending the \mthind{Morph}{bounds} message to a morph answers its bounding box, which is an instance of \clsind{Rectangle}.
Rectangles understand many messages that create other rectangles of related geometry; here we use the \ct{insetBy:} message with a point as its argument to create first a rectangle with reduced height, and then another rectangle with reduced width.

\dothis{To test your new morph, execute \ct{SBECrossMorph new} \mthind{Morph}{openInWorld}.}
The result should look something like \figref{cross}.
However, you will notice that the sensitive zone\,---\,where you can click to grab the morph\,---\,is still the whole bounding box.  Let's fix this.

When the Morphic framework needs to find out which Morphs lie under the cursor, it sends the message \ct{containsPoint:} to all the morphs whose bounding boxes lie under the mouse pointer.
So, to limit the sensitive zone of the morph to the cross shape, we need to override the \ct{containsPoint:} method.


\dothis{Define the following method in class \ct{SBECrossMorph}:}

\needlines{4}
\begin{method}[firstContains]{Shaping the sensitive zone of the \ct{SBECrossMorph}.}
containsPoint: aPoint

	| crossHeight crossWidth horizontalBar verticalBar |
	crossHeight := self height / 3.0.
	crossWidth := self width / 3.0.
	horizontalBar := self bounds insetBy: 0@crossHeight.
	verticalBar := self bounds insetBy: crossWidth@0.
	^ (horizontalBar containsPoint: aPoint)
		or: [verticalBar containsPoint: aPoint]
\end{method}

This method uses the same logic as \ct{drawOn:}, so we can be confident that the points for which \ct{containsPoint:} answers \ct{true} are the same ones that will be colored in by \ct{drawOn}.
Notice how we leverage the \mthind{Rectangle}{containsPoint:} method in class \ct{Rectangle} to do the hard work.

There are two problems with the code in \mthsref{firstDrawOn} and \ref{mth:firstContains}.
The most obvious is that we have duplicated code.
This is a cardinal error: if we find that we need to change the way that \ct{horizontalBar} or \ct{verticalBar} are calculated, we are quite likely to forget to change one of the two occurrences.
The solution is to factor out these calculations into two new methods, which we put in the \ct{private} protocol:

\needlines{4}
\begin{method}{\ct{horizontalBar}.}
SBECrossMorph>>>horizontalBar

	| crossHeight |
	crossHeight := self height / 3.0.
	^ self bounds insetBy: 0 @ crossHeight
\end{method}

\needlines{4}
\begin{method}{\ct{verticalBar}.}
SBECrossMorph>>>verticalBar

	| crossWidth |
	crossWidth := self width / 3.0.
	^ self bounds insetBy: crossWidth @ 0
\end{method}

\noindent
We can then define both \ct{drawOn:} and \ct{containsPoint:} using these methods:

\needlines{4}
\begin{method}{Refactored \ct{SBECrossMorph>>>drawOn:}.}
SBECrossMorph>>>drawOn: aCanvas

	aCanvas fillRectangle: self horizontalBar color: self color.
	aCanvas fillRectangle: self verticalBar color: self color.
\end{method}

\needlines{4}
\begin{method}{Refactored \ct{SBECrossMorph>>>containsPoint:}.}
SBECrossMorph>>>containsPoint: aPoint

	^ (self horizontalBar containsPoint: aPoint)
		or: [self verticalBar containsPoint: aPoint]
\end{method}

This code is much simpler to understand, largely because we have given meaningful names to the private methods.
In fact, it is so simple that you may have noticed the second problem:
The area in the center of the cross, which is under both the horizontal and the vertical bars, is drawn twice.
This doesn't matter when we fill the cross with an opaque color, but the bug becomes apparent immediately if we draw a semi-transparent cross, as shown in \figref{overdrawBug}.

\begin{figure}[t]
\begin{minipage}[t]{0.48\textwidth}
	\ifluluelse
		{\centerline{\includegraphics[scale=0.6]{overdrawBug}}}
		{\centerline{\includegraphics{overdrawBug}}}
	\caption{The center of the cross is filled twice with the color.
		\label{fig:overdrawBug}}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
	\ifluluelse
		{\centerline{\includegraphics[scale=0.6]{hairlineBug}}}
		{\centerline{\includegraphics{hairlineBug}}}
	\caption{The cross-shaped morph, showing a row of unfilled pixels.
		\label{fig:bug}}
\end{minipage}
\end{figure}

\needlines{4}
\dothis{Execute the following code in  a workspace, line by line:}

\begin{code}{}
m := SBECrossMorph newBounds: (0 @ 0 corner: 300 @ 300).
m openInWorld.
m color: (Color blue alpha: 0.3).
\end{code}

\noindent
The fix is to divide the vertical bar into three pieces, and to fill only the top and bottom.
Once again we find a method in class \ct{Rectangle} that does the hard work for us: \ct{r1 areasOutside: r2} answers an array of rectangles comprising the parts of \ct{r1} outside \ct{r2}.
Here is the revised code:

\begin{method}{The revised \ct{drawOn:} method, which fills the center of the cross once.}
SBECrossMorph>>>drawOn: aCanvas

	| topAndBottom |
	aCanvas fillRectangle: self horizontalBar color: self color.
	topAndBottom := self verticalBar areasOutside: self horizontalBar.
	topAndBottom do: [:each | aCanvas fillRectangle: each color: self color].
\end{method}

This code seems to work, but if you try it on some crosses and resize them, you may notice that at some sizes, a one-pixel wide line separates the bottom of the cross from the remainder, as shown in \figref{bug}.
This is due to rounding: when the size of the rectangle to be filled is not an integer, \ct{fillRectangle: color:}
seems to round inconsistently, leaving one row of pixels unfilled.
We can work around this by rounding explicitly when we calculate the sizes of the bars.

\needlines{5}
\begin{method}{\ct{SBECrossMorph>>>horizontalBar} with explicit rounding.}
SBECrossMorph>>>horizontalBar

	| crossHeight |
	crossHeight := (self height / 3.0) rounded.
	^ self bounds insetBy: 0 @ crossHeight
\end{method}

\needlines{5}
\begin{method}{\ct{SBECrossMorph>>>verticalBar} with explicit rounding.}
SBECrossMorph>>>verticalBar

	| crossWidth |
	crossWidth := (self width / 3.0) rounded.
	^ self bounds insetBy: crossWidth @ 0
\end{method}



%=================================================================
%\section{Composing Morphs}

%\on{The source code is in the examples directory.
%For the moment I prefer to leave out the examples, as they do not add much.}

%Below, we present a few morphs that were designed for a course project.

%\paragraph{An adhesive Label} The \ct{LabelStickerMorph} is a metaphor for an adhesive label with a colored border and three lines of text (\figref{labeler}, \egref{labeler}).

%\begin{figure}[ht]
%	\centerline{\includegraphics[width=0.25\textwidth]{labeler}}
%	\caption{The sticker label morph.
%		\label{fig:labeler}}
%\end{figure}

%\begin{example}[labeler]{Creating a sticker label}{}
%label := LabelstickerMorph new openInWorld.
%label text1: 'Confiture sans sucre';
%	text2: 'Fraises du jardin';
%	text3: '9 mai 2006'.
%label lineColor: Color blue
%\end{example}

%\paragraph{A Number Pyramid}
%The previous morph is designed by overriding the \ct{drawOn:} method.
%We built \ct{PyramidMorph} by composing morphs: we used \ct{TextMorph}s to make the blocks and added them to a base morph (\figref{pyramid}, \egref{pyramid}). \damien{figure does not match text... no numbers? Where is the code?}
%\begin{figure}[ht]
%	\centerline{\includegraphics{pyramid}}
%	\caption{The number pyramid morph.
%		\label{fig:pyramid}}
%\end{figure}

%\begin{example}[pyramid]{Manipulating the number pyramid}{}
%pyramid := (PyramidMorph base: 4) openInWorld.
%pyramid block: 8 value: 2
%\end{example}


%=================================================================
\section{Interaction and animation}

To build live user-interfaces using morphs, we need to be able to interact with them using the mouse and the keyboard.
Moreover, the morphs need to be able to respond to user input by changing their appearance and position\,---\,that is, by animating themselves.


\subsection{Mouse events}

When a mouse button is pressed, Morphic sends each morph under the mouse pointer the message \ct{handlesMouseDown:}.
If a morph answers \ct{true}, then Morphic immediately sends it the \mthind{Morph}{mouseDown:} message; it also sends the \mthind{Morph}{mouseUp:} message when the user releases the mouse button.
If all morphs answer \ct{false}, then Morphic initiates a drag-and-drop operation.
As we will discuss below, the \ct{mouseDown:} and \ct{mouseUp:} messages are sent with an argument\,---\,a \clsind{MouseEvent} object\,---\,that encodes the details of the mouse action.

Let's extend \ct{SBECrossMorph} to handle mouse events.
We start by ensuring that all crossMorphs answer \ct{true} to the \mthind{Morph}{handlesMouseDown:} message.

\dothis{Add this method to \ct{SBECrossMorph}:}
\begin{method}{Declaring that \ct{SBECrossMorph} will react to mouse clicks.}
SBECrossMorph>>>handlesMouseDown: anEvent

	^ true
\end{method}

Suppose that when the red mouse button is clicked, we want to change the color of the cross to red, and when the yellow button is clicked we want to change the color to yellow.
This can be accomplished by \mthref{mouseDown}.

\needlines{7}
\begin{method}[mouseDown]{Reacting to mouse clicks by changing the morph's color.}
SBECrossMorph>>>mouseDown: anEvent

	anEvent redButtonPressed
		ifTrue: [self color: Color red].
	anEvent yellowButtonPressed
		ifTrue: [self color: Color yellow].
	self changed.
\end{method}

\ab{I added this note:}
Notice that in addition to changing the color of the morph, this method also sends \ct{self changed}.
This makes sure that morphic sends \ct{drawOn:} in a timely fashion.
\ab{However, the \ct{self changed} message seems to be entirely unnecessary; the color changes instantly without it.}
Note also that once the morph handles \ind{mouse events}, you can no longer grab it with the mouse and move it.
Instead you have to use the halo: blue-click on the morph to make the halo appear and grab either the brown move handle \moveHandle{} or the black pickup handle \grabHandle{} at the top of the morph.

The \ct{anEvent} argument of \ct{mouseDown:} is an instance of \mbox{\clsind{MouseEvent},} which is a subclass of \lct{Mor\-phic\-Event}.
\ct{MouseEvent} defines the \mthind{MouseEvent}{redButtonPressed} and \mthind{MouseEvent}{yellowButtonPressed} methods.
Browse this class to see what other methods it provides to interrogate the mouse event.

\subsection{Keyboard events}

To catch \ind{keyboard events}, we need to take three steps.
\begin{enumerate}
	\item Give the ``keyboard focus'' to a specific morph:
	For instance, we can give focus to our morph when the mouse is over it.
	\item Handle the keyboard event itself with the \mthind{Morph}{handleKeystroke:} method:
	This message is sent to the morph that has keyboard focus when the user presses a key.
	\item Release the keyboard focus when the mouse is no longer over our morph.
\end{enumerate}

Let's extend \ct{SBECrossMorph} so that it reacts to keystrokes.
First, we need to arrange to be notified when the mouse is over the morph.
This will happen if our morph answers \ct{true} to the \mthind{Morph}{handlesMouseOver:} message.

\dothis{Declare that \ct{SBECrossMorph} will react when it is under the mouse pointer.}
\begin{method}{We want to handle ``mouse over'' events.}
SBECrossMorph>>>handlesMouseOver: anEvent

	^ true
\end{method}

\noindent
This message is the equivalent of \mthind{Morph}{handlesMouseDown:} for the mouse position.
When the mouse pointer enters or leaves the morph, the \mthind{Morph}{mouseEnter:} and \mthind{Morph}{mouseLeave:} messages are sent to it.

\dothis{Define two methods so that \ct{SBECrossMorph} catches and releases the keyboard focus, and a third method to actually handle the keystrokes.}
\begin{method}{Getting the keyboard focus when the mouse enters the morph.}
SBECrossMorph>>>mouseEnter: anEvent

	anEvent hand newKeyboardFocus: self.
\end{method}

\begin{method}{Handing back the focus when the pointer goes away.}
SBECrossMorph>>>mouseLeave: anEvent

	anEvent hand releaseKeyboardFocus: self.
\end{method}

\begin{method}[handleKeystroke]{Receiving and handling keyboard events.}
SBECrossMorph>>>handleKeystroke: anEvent

	| keyValue |
	keyValue := anEvent keyValue.
	keyValue = 30	 "up arrow"
		ifTrue: [self position: self position - (0 @ 1)].
	keyValue = 31	 "down arrow"
		ifTrue: [self position: self position + (0 @ 1)].
	keyValue = 29	 "right arrow"
		ifTrue: [self position: self position + (1 @ 0)].
	keyValue = 28	 "left arrow"
		ifTrue: [self position: self position - (1 @ 0)].
\end{method}

We have written this method so that you can move the morph using the arrow keys.
Note that when the mouse is no longer over the morph, the \mthind{Morph}{handleKeystroke:} message is not sent, so the morph stops responding to keyboard commands.
To discover the key values, you can open a Transcript window and add \glbind{Transcript} \ct{show: anEvent keyValue} to \mthref{handleKeystroke}.
The \ct{anEvent} argument of \ct{handleKeystroke:} is an instance of \clsind{KeyboardEvent}, another subclass of \clsind{MorphicEvent}. Browse this class to learn more about keyboard events.

\subsection{Global accessors for UI objects}

In complex applications, one may need to refer to the currently processed event without having it available in the current method.
While we should avoid such situations in general, there is an accessor message defined on \ct{Object}, \mthind{Object}{currentEvent}, that allows us to retrieve the event currently being handled again from any method in any object.
To do so, we can simply write \ct{self currentEvent} in an arbitrary method.
Analogously, there are \mthind{Object}{currentHand} and \mthind{Object}{currentWorld} to retrieve the current \clsind{HandMorph} (which represents your cursor) or \clsind{PasteUpMorph} (which contains all other morphs displayed at your screen).

In some cases, one may also want to directly control the user interaction without following the usual event handling control flow.
As an example, we may want to track the mouse cursor and find out which point the user clicks next.
Implementing this via the usual event-handling protocol would be complicated because we want to handle click events for morphs whose methods we do not control.%
\footnote{Actually, there is an advanced mechanism called \emph{event-bubbling and -capturing filters} that would be applicable to this problem.
	However, this approach requires a bit more code and thus is not optimally suited for our simple use case.}
For cases like this, there is the class \clsind{EventSensor} an instance of which you can retrieve by evaluating \ct{EventSensor default}.
To implement our example, we can do the following:
\begin{method}{Retrieving information about the cursor from \ct{EventSensor} without using events.}
getPositionFromClick

	| position |
	[EventSensor default anyButtonPressed] whileFalse: [
		position := EventSensor default cursorPoint].
	^ position
\end{method}

However, keep in mind that all these approaches use global state which can lead to problems (just imagine a \sq image that deals with multiple cursors\footnote{This is actually the case in some multi-touch implementations for \sq{}.}, which cursor's position are we retrieving now?).
So whenever possible, try to avoid these accessors and stick with the usual event-handling protocol instead.

\subsection{Morphic animations}

Morphic provides a simple animation system with two main methods: \mthind{Morphic}{step} is sent to a morph at regular intervals of time, while \mthind{Morphic}{stepTime} specifies the time in milliseconds between \ct{step}s.%
\footnote{\ct{stepTime} is actually the \emph{minimum} time between \ct{step}s.
	If you ask for a \ct{stepTime} of 1\,ms, don't be surprised if \sq is too busy to step your morph that often.}
In addition, \mthind{Morphic}{startStepping} turns on the stepping mechanism, while \mthind{Morphic}{stopStepping} turns it off again;  \mthind{Morphic}{isStepping} can be used to find out whether a morph is currently being stepped.
\index{Morphic!animation}

\dothis{Make \ct{SBECrossMorph} blink by defining these methods as follows:}
\begin{method}{Defining the animation time interval.}
SBECrossMorph>>>stepTime

	^ 100
\end{method}
\begin{method}{Making a step in the animation.}
SBECrossMorph>>>step

	(self color diff: Color black) < 0.1
		ifTrue: [self color: Color red]
		ifFalse: [self color: self color darker].
\end{method}
\noindent
To start things off, you can open an inspector on a \ct{SBECrossMorph} (using the debug handle \debugHandle{} in the morphic halo), type \ct{self startStepping} in the small workspace pane at the bottom, and \menu{do it}.
Alternatively, you can modify the \ct{handleKeystroke:} method so that you can use the $+$ and $-$ keys to start and stop stepping.

\dothis{Add the following code to \mthref{handleKeystroke}:}

\begin{code}{}
	keyValue = $+ asciiValue
		ifTrue: [self startStepping].
	keyValue = $- asciiValue
		ifTrue: [self stopStepping].
\end{code}

% \on{You can also \menu{debug \go inspect morph} and evaluate: \ct{self currentWorld startStepping: self}.}

%=================================================================
\section{Dialog windows}

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: 'figures/dialog.png' building: [:helper |
	helper runModal: [
		Project uiManager
			request: 'What''s your name?'
			initialAnswer: 'no name'].
]
\end{ExecuteSmalltalkScript}
\begin{figure}
\centering
\begin{minipage}[t]{0.35\textwidth}
	\centerline{\includegraphics[width=\textwidth]{dialog}}
	\caption{Dialog displayed by \ct{UIManager>>>request:initialAnswer:}.
		\label{fig:dialogName}}
\end{minipage}
\hfill
\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: 'figures/popup.png' building: [:helper |
	helper runModal: [
		Project uiManager
			chooseFrom: #('circle' 'oval' 'square' 'rectangle' 'triangle')]
]
\end{ExecuteSmalltalkScript}
\begin{minipage}[t]{0.56\textwidth}
	\centerline{\includegraphics[width=\textwidth]{popup}}
	\caption{Dialog displayed by \ct{UIManager>>>chooseFrom:}.
		\label{fig:dialogChoosing}}
\end{minipage}
\end{figure}

To prompt the user for input, the \clsind{UIManager} class provides a few ready-to-use dialog boxes.
For instance, the \mthind{UIManager}{request:initialAnswer:} method returns the string entered by the user (\figref{dialogName}).
However, \clsind{UIManager} is an abstract class that has several subclasses such as \clsind{MorphicUIManager}, \clsind{MVCUIManager}, and others.
What's the reason for this?

\sq supports a range of different UI systems, called \emph{\index{projects}}, of which Morphic is only one of many.
For instance, another project type in \sq is \emph{\index{MVC}} (named after its tripartite Model-View-Controller architecture) which was the only available UI system in classic \st-80.
To allow developers to write code that works for any projects, \sq provides the \clsind{UIManager} class hierarchy that defines a consistent interface to invoke user dialogs for any UI system.
You can retrieve an appropriate subclass instance of \clsind{UIManager} for the current project by executing the method \cmind{Project class}{uiManager}.

For example, to display the request dialog in \figref{dialogName}, you can send the message \ct{request:initialAnswer:}:
\begin{code}{}
Project uiManager
	request: 'What''s your name?'
	initialAnswer: 'no name'
\end{code}

To display the request dialog in \figref{dialogChoosing}, send a \ct{chooseFrom:}:
\begin{code}{}
Project uiManager
	chooseFrom: #('circle' 'oval' 'square' 'rectangle' 'triangle')
\end{code}

%=================================================================
\section{Drag-and-drop}

Morphic also supports drag-and-drop.
Let's examine a simple example with two morphs, a receiver morph and a dropped morph.
The receiver will accept a morph only if the dropped morph matches a given condition:
In our example, the morph should be blue.
If it is rejected, the dropped morph decides what to do.

\dothis{Let's first define the receiver morph:}
\begin{classdef}{Defining a morph on which we can drop other morphs.}
Morph subclass: #ReceiverMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SBE-Morphic'
\end{classdef}

\dothis{Now define the initialization method in the usual way:}
\begin{method}{Initializing \ct{ReceiverMorph}.}
ReceiverMorph>>>initialize

	super initialize.
	color := Color red.
	bounds := 0 @ 0 extent: 200 @ 200.
\end{method}

How do we decide if the receiver morph will accept or repel the dropped morph?
In general, both of the morphs will have to agree to the interaction.
The receiver does this by responding to \mthind{Morph}{wantsDroppedMorph:event:}; the first argument is the dropped morph, and the second the mouse event, so that the receiver can, for example, see if any modifier keys were held down at the time of the drop.
The dropped morph is also given the opportunity to check and see if it likes the morph onto which it is being dropped; it is sent the message \ct{wantsToBeDroppedInto:}.
The default implementation of this method (in the class \ct{Morph}) answers \ct{true}.

\begin{method}{Accept dropped morphs based on their color.}
ReceiverMorph>>>wantsDroppedMorph: aMorph event: anEvent

	^ aMorph color = Color blue
\end{method}

What happens to the dropped morph if the receiving morph doesn't want it?
The default behavior is for it to do nothing, that is, to sit on top of the receiving morph, but without interacting with it.
A more intuitive behavior is for the dropped morph to go back to its original position.
This can be achieved by the receiver answering \ct{true} to the message \mthind{Morph}{repelsMorph:event:} when it doesn't want the dropped morph:

\needlines{4}
\begin{method}{Changing the behavior of the dropped morph when it is rejected.}
ReceiverMorph>>>repelsMorph: aMorph event: anEvent
	^ (self wantsDroppedMorph: aMorph event: anEvent) not
\end{method}

That's all we need as far as the receiver is concerned.

\dothis{Create instances of \clsind{ReceiverMorph} and \clsind{EllipseMorph} in a workspace:}
\begin{code}{}
ReceiverMorph new openInWorld.
EllipseMorph new openInWorld.
\end{code}
\noindent
Try to drag-and-drop the yellow \ct{EllipseMorph} onto the receiver.
It will be rejected and sent back to its initial position.

\dothis{To change this behavior, change the color of the ellipse morph to \ct{Color blue} using an inspector.
	Blue morphs should be accepted by the \ct{ReceiverMorph}.}

Let's create a specific subclass of \ct{Morph}, named \ct{DroppedMorph}, so we can experiment a bit more:

\begin{classdef}{Defining a morph we can drag-and-drop onto \ct{ReceiverMorph}.}
Morph subclass: #DroppedMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SBE-Morphic'
\end{classdef}

\needlines{5}
\begin{method}{Initializing \ct{DroppedMorph}.}
DroppedMorph>>>initialize

	super initialize.
	self
		color: Color blue;
		position: 250 @ 100.
\end{method}

Now we can specify what the dropped morph should do when it is rejected by the receiver; here it will stay attached to the mouse pointer:

\needlines{6}
\begin{method}{Reacting when the morph was dropped but rejected.}
DroppedMorph>>>rejectDropMorphEvent: anEvent

	| h |
	h := anEvent hand.
	WorldState addDeferredUIMessage: [h grabMorph: self].
	anEvent wasHandled: true.
\end{method}

Sending the \mthind{MorphicEvent}{hand} message to an event answers the \emph{hand}, an instance of \ct{HandMorph} that represents the mouse pointer and whatever it holds.
Here we tell the \ct{World} that the hand should grab \ct{self}, the rejected morph.

\dothis{Create two instances of \ct{DroppedMorph}, and then drag-and-drop them onto the receiver.}
\begin{code}{}
ReceiverMorph new openInWorld.
(DroppedMorph new color: Color blue) openInWorld.
(DroppedMorph new color: Color green) openInWorld.
\end{code}
\noindent
The green morph is rejected and therefore stays attached to the mouse pointer.

%=================================================================
\section{A complete example}

Let's design a morph to roll a die.
Clicking on it will display the values of all sides of the die in a quick loop, and another click will stop the animation.

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: 'figures/die.png' building: [:helper |
	SBEDieMorph new
		openCenteredInWorld;
		stopStepping;
		dieValue: 5;
		addHalo
]
\end{ExecuteSmalltalkScript}
\begin{figure}[ht]
	\centerline{\includegraphics[scale=0.65]{die}}
	\caption{The die in Morphic.
		\label{fig:dialogDie}}
\end{figure}

\dothis{Define the die as a subclass of \clsind{BorderedMorph} instead of \ct{Morph} because we will make use of the border.}

\needlines{6}
\begin{classdef}{Defining the die morph.}
BorderedMorph subclass: #SBEDieMorph
	instanceVariableNames: 'faces dieValue isStopped'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'SBE-Morphic'
\end{classdef}

The instance variable \ct{faces} records the number of faces on the die; we allow dice with up to 9 faces!
\ct{dieValue} records the value of the face that is currently displayed, and \ct{isStopped} is true if the die animation has stopped running.
To create a die instance, we define the \ct{faces: n} method on the \emph{class} side of \clsind{SBEDieMorph} to create a new die with \ct{n} faces.
\begin{method}{Creating a new die with the number of faces we like.}
SBEDieMorph class>>>faces: aNumber

	^ self new faces: aNumber
\end{method}

The \ct{initialize} method is defined on the instance side in the usual way; remember that \ct{new} sends \ct{initialize} to the newly-created instance.
\begin{method}{Initializing instances of \ct{SBEDieMorph}.}
SBEDieMorph>>>initialize

	super initialize.
	self
		extent: 50 @ 50;
		useGradientFill; borderWidth: 2; useRoundedCorners;
		setBorderStyle: #complexRaised;
		color: Color green.
	dieValue := 1.
	faces := 6.
	isStopped := false.
\end{method}

We use a few methods of \ct{BorderedMorph} to give a nice appearance to the die: a thick border with a raised effect, rounded corners, and a color gradient on the visible face.
We define the instance method \ct{faces:} to check for a valid parameter as follows:

\begin{method}{Setting the number of faces of the die.}
SBEDieMorph>>>faces: aNumber
	"Set the number of faces"

	self assert: (aNumber isInteger and: [aNumber > 0] and: [aNumber <= 9]).
	faces := aNumber.
\end{method}

Now that we have created an acessor method for this instance variable, we can also use it in the \ct{initialize} method to assure that all changes to the variable go through the accessor method.

It may be good to review the order in which the messages are sent when a die is created.
For instance, if we start by evaluating \ct{SBEDieMorph faces: 9}:
\begin{enumerate}
	\item The class method \ct{SBEDieMorph class>>>faces:} sends \ct{new} to \ct{SBEDieMorph class}.
	\item The method for \ct{new} (inherited by \ct{SBEDieMorph class} from \ct{Behavior}) creates the new instance and sends it the \ct{initialize} message.
	\item The \ct{initialize} method in \ct{SBEDieMorph} sets \ct{faces} to an initial value of 6.
	\item \ct{SBEDieMorph class>>>new} returns to the class method \ct{SBEDieMorph class>>>faces:}, which then sends the message \ct{faces: 9} to the new instance.
	\item The instance method \ct{SBEDieMorph>>>faces:} now executes, setting the \ct{faces} instance variable to 9.
\end{enumerate}

Before defining \ct{drawOn:}, we need a few methods to place the dots on the displayed face:
\begin{methods}{Nine methods for placing points on the faces of the die.}
SBEDieMorph>>>face1
	^ {0.5 @ 0.5}
SBEDieMorph>>>face2
	^ {0.25 @ 0.25 . 0.75 @ 0.75}
SBEDieMorph>>>face3
	^ {0.25 @ 0.25 . 0.75 @ 0.75 . 0.5 @ 0.5}
SBEDieMorph>>>face4
	^ {0.25 @ 0.25 . 0.75 @ 0.25 . 0.75 @ 0.75 . 0.25 @ 0.75}
SBEDieMorph>>>face5
	^ {0.25 @ 0.25 . 0.75 @ 0.25 . 0.75 @ 0.75 . 0.25 @ 0.75 . 0.5 @ 0.5}
SBEDieMorph>>>face6
	^ {0.25 @ 0.25 . 0.75 @ 0.25 . 0.75 @ 0.75 . 0.25 @ 0.75 . 0.25 @ 0.5 . 0.75 @ 0.5}
SBEDieMorph>>>face7
	^ {0.25 @ 0.25 . 0.75 @ 0.25 . 0.75 @ 0.75 . 0.25 @ 0.75 . 0.25 @ 0.5 . 0.75 @ 0.5 . 0.5 @ 0.5}
SBEDieMorph >>>face8
	^ {0.25 @ 0.25 . 0.75 @ 0.25 . 0.75 @ 0.75 . 0.25 @ 0.75 . 0.25 @ 0.5 . 0.75 @ 0.5 . 0.5 @ 0.5 . 0.5 @ 0.25}
SBEDieMorph >>>face9
	^ {0.25 @ 0.25 . 0.75 @ 0.25 . 0.75 @ 0.75 . 0.25 @ 0.75 . 0.25 @ 0.5 . 0.75 @ 0.5 . 0.5 @ 0.5 . 0.5 @ 0.25 . 0.5 @ 0.75}
\end{methods}
\on{kind of ugly boilerplate code -- should be a nice way to map these more elegantly to coordinates.}

These methods define collections of the coordinates of dots for each face.
The coordinates are in a square of size $1 \times 1$; we will simply need to scale them to place the actual dots.

The \ct{drawOn:} method does two things:
It draws the die background with the \ct{super}-send, and then draws the dots.
\begin{method}{Drawing the die morph.}
SBEDieMorph>>>drawOn: aCanvas

	super drawOn: aCanvas.
	(self perform: ('face' , self dieValue) asSymbol) do: [:aPoint |
		self drawDotOn: aCanvas at: aPoint].
\end{method}

The second part of this method uses the reflective capacities of \st.
Drawing the dots of a face is a simple matter of iterating over the collection given by the \ct{faceX} method for that face, sending the \ct{drawDotOn:at:} message for each coordinate.
To call the correct \ct{faceX} method, we use the \mthind{Object}{perform:} method which sends a message built from a string, here \ct{('face', dieValue asString) asSymbol}.
\index{reflection}

\begin{method}{Drawing a single dot on a face.}
SBEDieMorph>>>drawDotOn: aCanvas at: aPoint

	aCanvas
		fillOval: (Rectangle
			center: self position + (self extent * aPoint)
			extent: self extent / 6)
		color: Color black.
\end{method}

Since the coordinates are normalized to the $[0{:}1]$ interval, we scale them to the dimensions of our die: \ct{self extent * aPoint}.

\dothis{We can already create a die instance from a workspace:}
\begin{code}{}
(SBEDieMorph faces: 6) openInWorld.
\end{code}

To change the displayed face, we create an accessor that we can use as \ct{myDie dieValue: 4}:
\begin{method}{Setting the current value of the die.}
SBEDieMorph>>>dieValue: aNumber

	self assert: (aNumber isInteger and: [aNumber between: 1 and: faces]).
	dieValue := aNumber.
	self changed.
\end{method}

Now we will use the animation system to show quickly all the faces:
\needlines{3}
\index{Morphic!animation}
\begin{methods}{Animating the die.}
SBEDieMorph>>>stepTime

	^ 100


SBEDieMorph>>>step

	isStopped ifFalse: [self dieValue: (1 to: self faces) atRandom].
\end{methods}
Now the die is rolling!

To start or stop the animation by clicking, we will use what we learned previously about mouse events.
First, activate the reception of mouse events:

\begin{methods}{Handling mouse clicks to start and stop the animation.}
SBEDieMorph>>>handlesMouseDown: anEvent

	^ true


SBEDieMorph>>>mouseDown: anEvent

	anEvent redButtonPressed ifTrue: [
		isStopped := isStopped not].
\end{methods}
Now the die will roll or stop rolling when we click on it.

% Most of the work on \ct{SBEDieMorph} was done with an instance of it living in the environment; this is quite nice when to tweak programs.

%=================================================================
\section{More about the canvas}

The \ct{drawOn:} method has an instance of \clsindmain{Canvas} as its sole argument; the canvas is the area on which the morph draws itself.
By using the graphics methods of the canvas you are free to give the appearance you want to a morph.
If you browse the inheritance hierarchy of the \ct{Canvas} class, you will see that it has several variants.
The default variant of \ct{Canvas} is \clsind{FormCanvas}; you will find the key graphics methods in \ct{Canvas} and \ct{FormCanvas}.
These methods can draw points, lines, polygons, rectangles, ellipses, text, and images with rotation and scaling.

It is also possible to use other kinds of canvas, to obtain transparent morphs, more graphics methods, antialiasing, and so on.
To use these features you will need an \clsind{AlphaBlendingCanvas} or a \clsind{BalloonCanvas}.
But how can you obtain such a canvas in a \ct{drawOn:} method, when \ct{drawOn:} receives an instance of \ct{FormCanvas} as its argument?
Fortunately, you can transform one kind of canvas into another.

\dothis{To use a canvas with a 0.5 alpha-transparency in \ct{SBEDieMorph}, redefine \ct{drawOn:} like this:}
\needlines{7}
\begin{method}{Drawing a translucent die.}
SBEDieMorph>>>drawOn: aCanvas

	| theCanvas |
	theCanvas := aCanvas asAlphaBlendingCanvas: 0.5.
	super drawOn: theCanvas.
	(self perform: ('face' , dieValue asString) asSymbol) do: [:aPoint |
		self drawDotOn: theCanvas at: aPoint].
\end{method}
\noindent
That's all you need to do!

If you're curious, have a look at the \mthind{Canvas}{asAlphaBlendingCanvas:} method.
You can also get antialiasing by using \clsind{BalloonCanvas} and transforming the die drawing methods as shown in \mthsref{aadie}.

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: 'figures/multiMorphs.png' building: [:helper |
	thisContext wrap: [:block | helper restoreMethods: {SBEDieMorph >> #drawOn:} after: block].
	SBEDieMorph compile: 'drawOn: aCanvas
	| theCanvas |
	theCanvas := aCanvas asAlphaBlendingCanvas: 0.5.
	super drawOn: theCanvas.
	(self perform: (''face'' , dieValue asString) asSymbol)
		do: [:aPoint | self drawDotOn: theCanvas at: aPoint]'
	.
	{ Morph new
		position: 30 @ 0;
		color: Color red.
	Morph new
		position: 0 @ 20;
		color: Color blue.
	SBEDieMorph new
		position: 25 @ 18;
		extent: 75 @ 75 } do: #openInWorld.
	helper takeScreenshot. "before the drawing method is reverted"
]
\end{ExecuteSmalltalkScript}
\begin{figure}[ht]
	\centerline{\includegraphics[scale=0.7]{multiMorphs}}
	\caption{The die displayed with alpha-transparency.
		\label{fig:multiMorphs}}
\end{figure}

\needlines{6}
\begin{methods}[aadie]{Drawing an antialiased die.}
SBEDieMorph>>>drawOn: aCanvas

	| theCanvas |
	theCanvas := aCanvas asBalloonCanvas aaLevel: 3.
	super drawOn: aCanvas.
	(self perform: ('face' , dieValue asString) asSymbol) do: [:aPoint |
		self drawDotOn: theCanvas at: aPoint].


SBEDieMorph>>>drawDotOn: aCanvas at: aPoint

	aCanvas
		drawOval: (Rectangle
			center: self position + (self extent * aPoint)
			extent: self extent / 6)
		color: Color black
		borderWidth: 0
		borderColor: Color transparent.
\end{methods}

%=================================================================
\section{Chapter summary}

Morphic is a graphical framework in which graphical interface elements can be dynamically composed.

\begin{itemize}
  \item You can convert an object into a morph and display that morph on the screen by sending it the messages \ct{asMorph openInWorld}.
  \item You can manipulate a morph by blue-clicking on it and using the handles that appear.
  	(Handles have help balloons that explain what they do.)
  \item You can compose morphs by sending the message \ct{addMorph:} or by using the \menu{embed into} feature, either through the menu or via drag and drop.
  \item You can subclass an existing morph class and redefine key methods, like \ct{initialize} and \ct{drawOn:}.
  \item You can control how a morph reacts to mouse and keyboard events by redefining the methods \ct{handlesMouseDown:}, \ct{handlesMouseOver:}, \etc
  \item You can animate a morph by defining the methods \ct{step} (what to do) and \ct{stepTime} (the number of milliseconds between steps).
  \item Various pre-defined morphs, like \ct{PopUpMenu} and \ct{FillInTheBlank}, are available for interacting with users.
  \item \ct{Canvas} objects provide basic drawing operations, advanced features such as antialiasing support are provided by \ct{Canvas} subclasses.
\end{itemize}

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================

%-----------------------------------------------------------------
