% $Author$
% $Date$
% $Revision$
%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.815in,.815in},
		vmargin={.98in,.98in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	\renewcommand{\nnbb}[2]{} % Disable editorial comments
\fi
%=================================================================
\chapter{The Squeak programming environment}
\label{cha:env}

The goal of this chapter is to show you how to develop programs in the \Squeak programming environment.
You have already seen how to define methods and classes using the system browser; this chapter will show you more of the features of the system browser, and introduce you to some of the other browsers.

Sometimes your program does not work as you expect.
Squeak has an excellent debugger, but like most powerful tools, it can be confusing on first use.
We will walk you through a debugging session and demonstrate some of the features of the debugger.

One of the unique features of Smalltalk is that while you are programming, you are living in a world of live objects, not in a world of static program text.
This makes it possible to get very rapid feedback while programming, which makes you more productive.
There are two tools that let you look at, and indeed change, live objects: the \emph{inspector} and the \emph{explorer}.

%Finally, you may find a bug in Squeak as you work; we explain how to report bugs, and how to submit bug fixes.
%\ab{Or I would, if I knew how.   We should do this, or remove the paragraph.}

%=========================================================
\section{Overview}
\label{sec:overview}

Smalltalk and modern graphical interfaces were developed together.
Even before the first public release of Smalltalk in 1983, Smalltalk had a self-hosting graphical development environment, and all Smalltalk development was taking place in it.
Let's start by looking at the main tools in \Squeak, all of which can be opened through the \emph{Tools} menu in the world docking bar at the top of the screen. Some of the tools can also be opened directly from the world menu.

\begin{itemize}
	\item {The \menu{Browser}} is a central development tool.
		You will use it to create, define, and organize your classes and methods.
		Using it you can also navigate through all the library classes:
		Unlike other environments where the source code is stored in separate files, in Smalltalk, all classes and methods are contained in the image.
		\index{system browser}

	\item{The \menu{Workspace}} is a window into which you can type input.
		It can be used for any purpose, but is most often used for typing Smalltalk expressions and executing them as \menu{do it}s.
		The use of the \ind{workspace} was also illustrated in \secref{transcript}.

	\item{The \menu{Transcript}} is a window on the \glbind{Transcript} output stream, which is useful for writing log messages and has already been described in \secref{transcript}.

	\item{The \menu{Test Runner}} lets you run and debug \SUnit tests, and is described in \charef{SUnit}.
		\index{Test Runner}
		\index{SUnit}

	\item{The \menu{Message Names}} tool is used to look at all of the methods with a particular selector, or with a selector containing a substring.
	\index{message name finder}

	\item{The \menu{Method Finder}} tool will also let you find methods, but according to what they \emph{do} as well as what they are called.
	\index{method finder}

	\item{The \menu{Process Browser} provides a view on all of the processes (threads) executing in Smalltalk.}
	\index{process browser}
\end{itemize}

The \menu{Debugger} has an obvious role but you will discover that it has a more central place compared to debuggers for other programming languages, because in Smalltalk you can \emph{program} in the \ind{debugger}.
The debugger is not launched from a menu or from the \toolsflap; it is normally entered by running a failing test, by typing \short{\textbf{.}} to interrupt a running process, or by inserting a \ct{self halt} expression in code.
\index{process!interrupting}

%=========================================================
\section{The system browser}
\label{sec:browser} % (fold)

There are actually several browsers in \sq: the standard system browser, the package browser, and the Monticello snapshot browser.
We will take a look at the standard \ind{system browser} first since the others are variations on it.
\figref{SystemBrowser0} shows the browser as it appears when you first open it from the world menu.

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/SystemBrowser0.png' frame: #morphs building: [:helper |
	SystemBrowser defaultOpenBrowser.
	helper scaleWindow: helper foregroundWindow.
]
\end{ExecuteSmalltalkScript}
\begin{figure}[htbp]
   \centering
   \ifluluelse
	 {\includegraphics[width=\textwidth]{SystemBrowser0} }
	 {\includegraphics[scale=.7]{SystemBrowser0} }
   \caption{The system browser.}
   \label{fig:SystemBrowser0}
\end{figure}

The four small panes at the top of the browser represent a hierarchic view of the methods in the system, much in the same way as the Mac OS X \textit{Finder} in column mode provide a view of the files on the disk (or the original \ind{NeXTstep} \textit{File Viewer}).
The leftmost pane lists \emph{categories} of classes; select one (say \scat{Kernel-Objects}) and the pane immediately to the right will then show all of the classes in that category.
\on{I adopted the spelling of NeXTstep recommended by wikipedia}

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/SystemBrowser1.png' frame: #morphs building: [:helper |
	ToolSet browseClass: Model.
	helper scaleWindow: helper foregroundWindow.
]
\end{ExecuteSmalltalkScript}
\begin{figure}[htbp]
   \centering
   \ifluluelse
	   {\includegraphics[width=\textwidth]{SystemBrowser1} }
	   {\includegraphics[scale=.7]{SystemBrowser1} }
   \caption{System Browser with the class \ct{Model} selected.
   \label{fig:SystemBrowserModel}}
\end{figure}

Similarly, if you select one of the classes in the second pane, say, \menu{Model} (see \figref{SystemBrowserModel}), the third pane will show all of the \emph{protocols} defined for that class, as well as a virtual protocol \prot{-{}-all-{}-}, which is selected by default (the browser sometimes refers to protocols as ``message categories'').
Protocols help organizing methods; they make it easier to find and think about the behavior of a class by breaking it up into smaller, conceptually coherent pieces.
The fourth pane shows the names of all of the methods defined in the selected protocol.
If you then select a method name, the source code of the corresponding method appears in the large pane at the bottom of the browser, where you can view it, edit it, and save the edited version.
If you select the class \menu{Model}, the protocol \protind{dependents}, and the method \menu{myDependents}, the browser should look like \figref{SystemBrowserMyDependents}.
\protindex{all}
\cmindex{Model}{myDependents}

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/SystemBrowserMyDependents.png' frame: #morphs building: [:helper |
	ToolSet browse: Model selector: #myDependents.
	helper scaleWindow: helper foregroundWindow.
]
\end{ExecuteSmalltalkScript}
\begin{figure}[htbp]
   \centering
   \ifluluelse
	   {\includegraphics[width=\textwidth]{SystemBrowserMyDependents}}
	   {\includegraphics[scale=.7]{SystemBrowserMyDependents}}
   \caption{System Browser showing the \ct{myDependents} method in class \ct{Model}.
   \label{fig:SystemBrowserMyDependents}}
\end{figure}

Unlike directories in the Mac OS X \emph{Finder}, the four top panes of the browser are not quite equal.
Whereas classes and methods are part of the Smalltalk language, system categories and protocols are not:
They are a convenience introduced by the programming tools to limit the amount of information that needs to be shown in each pane.
For example, if there were no categories, the browser would have to show a list of all of the methods in the selected class; for many classes, this list would be too large to navigate conveniently.
\index{Mac OS X Finder}

Because of this, the way that you create a new class category or protocol is different from the way that you create a new class or a new method.
To create a new class category, select \menu{new category} from the \ind{yellow button} menu in the class category pane; to create a new protocol, select \menu{new category} from the yellow button menu in the protocol pane.
Enter the name of the new thing in the dialog, and you are done: there is nothing more to a class category or a protocol than its name and its contents.
\index{category!creating}
\index{protocol!creating}

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/SystemBrowserClassCreation.png' frame: #morphs building: [:helper |
	ToolSet browseCategory: 'Kernel-Objects'.
	helper scaleWindow: helper foregroundWindow.
]
\end{ExecuteSmalltalkScript}
\begin{figure}[htbp]
   \centering
   \ifluluelse
	   {\includegraphics[width=\textwidth]{SystemBrowserClassCreation}}
	   {\includegraphics[scale=.7]{SystemBrowserClassCreation}}
   \caption{System Browser showing the class-creation template.
   \label{fig:SystemBrowserClassCreation}}
\end{figure}

Finally, you can influence what kind of information you want to see about a class through the three buttons below the second pane.
By default, the \button{instance} view is selected that shows you the ordinary methods provided by the class.
The \button{class} button changes the view to show the methods understood by the class itself (for more details see \charef{SqueakModel} and \charef{metaclasses}).
The \button{?} button changes the view to show the class comment of the class in the bottom pane, where you can edit and save it as you would with a method.

In contrast to creating categories or protocols, to create a new class or a new method, you will actually have to write some Smalltalk code.
If you deselect the currently selected category (most left pane) and then reselect it again, the main browser pane will display a class creation template (\figref{SystemBrowserClassCreation}).

You create a new class by editing this template: replace \ct{Object} by the name of the existing class of which you wish to create a subclass, replace \ct{NameOfSubclass} by the name that you would like to give to your new subclass, and fill in the instance variable names if you want some.
The category for the new class is by default the currently selected category, but you can change this too if you like.
If you already have the browser focussed on the class that you wish to subclass, you can get the same template with slightly different
initialization by using the yellow button menu in the class pane, and selecting \menu{more \ldots~\go{} subclass template}.
You can also just edit the definition of an existing class, changing the class name to something new.
In all cases, when you accept the new definition, the new class (the one whose name follows the \ct{#}) is created (as is
the corresponding metaclass).
Creating a class also creates a global variable that references the class, which is why you can refer to all of the existing classes by using their names.
\index{class!creation}
\index{system browser!defining a class}

The process of creating a new method is similar.
First select the class in which you want the method to live, and then select a protocol.
The browser will display a method-creation template, as shown in \figref{SystemBrowserMethodTemplate}, which you can fill-in or edit.
\index{method!creation}
\index{system browser!defining a method}

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/SystemBrowserMethodTemplate.png' frame: #morphs building: [:helper |
	ToolSet browseClass: Model category: #'morphic ui'.
	helper scaleWindow: helper foregroundWindow.
	helper focus: (helper codePaneOfBrowser: helper foregroundWindow).
]
\end{ExecuteSmalltalkScript}
\begin{figure}[htbp]
   \centering
   \ifluluelse
	   {\includegraphics [width=\textwidth]{SystemBrowserMethodTemplate}}
	   {\includegraphics[scale=.7]{SystemBrowserMethodTemplate}}
   \caption{System Browser showing the method-creation template.
   \label{fig:SystemBrowserMethodTemplate}}
\end{figure}

%---------------------------------------------------------
\subsection{The button bar}
\label{sec:ButtonBar}

The system browser provides several tools for exploring and analyzing code.
Those tools are most simply accessed from the horizontal \subind{system browser}{button bar} in the middle of the browser window.
The buttons are labeled \button{browse}, \button{senders}, \button{implementors}, \ldots{}\ %
\figref{SystemBrowserMethodTemplate} shows the complete set.

\subsubsection{Browsing code}
\label{sec:browsing}

The \button{browse} button opens a new system browser on the class or method that is currently selected.
It's often useful to have multiple browsers open at the same time.
When you are writing code you will almost certainly need at least two: one for the method that you are typing, and another to browse around the system to see what to type.
You can also open a browser on a class named by any selected text using the \short{b} \ind{keyboard shortcut}.
\index{system browser!browse button}
\index{keyboard shortcut!browse it}

\dothis{Try this: in a workspace window, type the name of a class (for instance \ct{ScaleMorph}), select it, and then press \short{b}. This trick is often useful; it works in any text window.}

\subsubsection{Senders and implementors of a message}
\label{sec:sendersImplementors}

\index{system browser!senders button}
The \button{senders} button will give you a list of all methods that may use the selected method.
With the browser open on \ct{ScaleMorph}, click on the \mthind{ScaleMorph}{checkExtent:} method in the method pane near the top right corner of the browser; the body of \ct{checkExtent:} displays in the bottom part of the browser.
If you now press the \button{senders} button, a menu will appear with \ct{checkExtent:} as the topmost item, and below it, all the messages that \ct{checkExtent:} sends (see \figref{SendersOfCheckEvent}).
Selecting an item in this menu will open a browser with the list of all methods in the image that send the selected message.
You can also quickly access the senders of messages by typing \short{n} (for {se\textbf{n}ders}).

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/SendersOfCheckEvent.png' frame: #morphs building: [:helper |
	| window sendersButton |
	ToolSet browse: ScaleMorph selector: #checkExtent:.
	window := helper foregroundWindow.
	helper scaleWindow: window extent: 600 @ 400.
	sendersButton := helper buttonLabeled: 'senders' in: window.
	helper
		runModal: [helper click: sendersButton buttons: #(left)]
		then: [helper dialogWindow center: (window bounds pointAtFraction: 3 @ 2 / 4)]
]
\end{ExecuteSmalltalkScript}
\begin{figure}[htbp]
	\begin{center}
   \ifluluelse
		{\includegraphics[width=\textwidth]{SendersOfCheckEvent}}
		{\includegraphics[scale=0.7]{SendersOfCheckEvent}}
	\end{center}
	\caption{A Class Browser opened on the \lct{ScaleMorph} class. Note the horizontal bar of buttons at the center of the browser; here we are using the \lct{senders} button.}
	\label{fig:SendersOfCheckEvent}
\end{figure}

\index{system browser!implementors button}
The \button{implementors} button works similarly, but instead of listing the senders of a message, it lists all of the classes that implement a method with the same selector.
To see this, select \lct{drawOn:} in the message pane and then bring up the ``implementors of drawOn:'' browser, either using the \button{implementors} button, or the \ind{yellow button} menu on the method pane, or just by typing \short{m} (for {i\textbf{m}ple\textbf{m}entors}) in the method pane with \menu{drawOn:} selected.
You should get a method list window showing a scrolling list of 108 classes that implement a \ct{drawOn:} method.
It shouldn't be all that surprising that so many classes implement this method:
\ct{drawOn:} is the message that is understood by every object that is capable of drawing itself on the screen.
While viewing any one of these methods, try browsing the senders of the \ct{drawOn:} message:
We found 72 methods that send this message.
You can also bring up an implementors browser at any time by selecting a message (including the arguments if it is a keyword message) and typing \short{m}.

The \menu{senders} button lists \emph{all} methods that send the chosen message: not all of these sends will necessarily result in the execution of the method you are currently looking at.
Indeed, much of the power of object-oriented programming comes from the fact that every message send is potentially \emph{polymorphic}, that is, it can work equally well on objects of any class.  Sometimes it is easy to figure out which method will be executed as result of a particular message send, and sometimes it is impossible; the senders and implementors tools don't try.

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/CanvasDraw.png' frame: #morphs building: [:helper |
	| method window list |
	helper systemNavigation browseAllCallsOn: #drawOn:.
	method := 'Canvas draw:*'.
	window := helper foregroundWindow.
	window extent: 600 @ 300; fullBounds.
	helper selectAnyListIn: helper foregroundWindow at: method andScrollIntoViewBy: 3.
]
\end{ExecuteSmalltalkScript}
\begin{figure}[htbp]
	\begin{center}
   \ifluluelse
		{\includegraphics[width=\textwidth]{CanvasDraw}}
		{\includegraphics[scale=0.7]{CanvasDraw}}
	\end{center}
	\caption{The Senders Browser showing that the \ct{Canvas>>>draw} method sends the \ct{drawOn:} message to its argument.	\label{fig:CanvasDraw}}
\end{figure}

As an example, we can look at the method \ct{Canvas>>>draw}, shown in \figref{CanvasDraw}.
You can see that this method sends \ct{drawOn:} to whatever object is passed to it as an argument, which could potentially be an instance of any class at all.
In general, there is no simple way for the browser to know which message sends might cause which methods to be executed\footnote{Dataflow analysis can generally help figure out the class of the receiver of some messages, but it is not applied in the Smalltalk tools}.
For this reason,  the ``senders'' browser shows exactly what its name suggests: all of the senders of the message with the chosen selector.
The \button{senders} button is nevertheless extremely useful when you need to understand how you can \emph{use} a method: it lets you navigate quickly through example uses.
Since all of the methods with the same selector ought to be used in the same way, all of the uses of a given message ought to be similar.
\index{system browser!senders button}

Another way to determine implementors of a message is to browse the hierarchy. If you look at the send of \ct{drawOn:} in \ct{AtomMorph>>>drawOn:}, you will see that it is a super \subind{super}{send}.
So we know that the method that will be executed will be in \ct{AtomMorph}'s superclass.
What class is that?
Click the \button{hierarchy} button and you will see that it is \ct{EllipseMorph}.
\index{system browser!hierarchy button}


\subsubsection{Versions of a method}
\label{sec:versions}

When you save a new \subind{method}{version} of a method, the old one is not lost.
\sq keeps all of the old versions, and allows you to compare different versions and to go back (``revert'') to an old version.

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/VersionsOfMouseUp.png' frame: #morphs building: [:helper |
	| list |
	helper restoreMethods: {SBECell >> #mouseUp:} after: [
		SBECell removeSelector: #mouseUp:.
		"Just open browser now so it will select the newest version by itself"
		SBECell
			compile: (String streamContents: [:stream | stream
				nextPutAll: 'mouseUp: anEvent';
				crtab; nextPutAll: 'mouseAction value']).
		SBECell organization classifyAllUnclassified.
		SBECell
			compile: (String streamContents: [:stream | stream
				nextPutAll: 'mouseUp: anEvent';
				crtab; nextPutAll: '(self containsPoint: anEvent position)';
				crtab: 2; nextPutAll: 'ifTrue: [mouseAction value]'])
			classified: (SBECell whichCategoryIncludesSelector: #mouseUp:).
		ToolSet browseVersionsOf: SBECell selector: #mouseUp:.
		helper scaleWindow: helper foregroundWindow extent: 500 @ 250.
		list := helper listMorphIncludingMatch: '*mouseUp*' in: helper foregroundWindow.
		list changeModelSelection: 1.
		helper takeScreenshot]
]
\end{ExecuteSmalltalkScript}
\begin{figure}[btp]
   \centering
   \ifluluelse
	   {\includegraphics[width=\textwidth]{VersionsOfMouseUp} }
	   {\includegraphics[scale=0.7]{VersionsOfMouseUp} }
   \caption{The \ind{versions browser} showing several versions of the \ct{SBECell>>>mouseUp:} method.}
   \label{fig:mouseUpVersions}
\end{figure}
The \button{versions} button gives access to the successive modifications made to the selected method.
In \figref{mouseUpVersions} we can see the versions of the \ct{mouseUp:} method that one of the authors created while writing the Quinto game described in \charef{firstApp}.

\index{system browser!versions button}
The top pane displays one line for each version of the method, listing the initials of the programmer who wrote it, the date and time at which it was saved, the names of the class and the method, and the protocol in which it was defined.
The current (active) version is at the top of the list; whichever version is selected is displayed in the bottom pane.
If the \menu{showDiffs} view is selected from the right most button, as it is in \figref{mouseUpVersions}, the display also shows the differences between the selected version and the one immediately older.
The \menu{prettyDiffs} view is useful if there have been changes to the layout: It pretty-prints both versions before differencing so that the differences that are displayed exclude formatting changes.
Through the leftmost button you can revert the method to the selected version.
The yellow button menu in the list of versions provides you further actions, such as comparing any version to the current one.

The existence of the \ind{versions browser} means that you never have to worry about preserving code that you think might no longer be needed:
Just delete it.
If you find that you \emph{do} need it, you can always revert to the old version, or copy the needed code fragment out of the old version and paste it into another method.
Get into the habit of using versions; ``commenting out'' code that is no longer needed is a bad practice because it makes the current code harder to read.
Smalltalkers rate code readability extremely highly.

\hint{What if you delete a method entirely, and then decide that you want it back?
	You can find the deletion in a change set, where you can ask to see versions with the \ind{yellow button} menu.
	The change set browser is described in \secref{sc:changeSet}.
	If you do not have a change set for the method, you can also browse your changes log using the \ind{Recover changes} or the \ind{Recover method versions} dialog from the \menu{Extras} menu in the main docking bar, see \secref{cantLoseCode}.}

\subsubsection{Method overridings}
\label{sec:overriding}

The \button{inheritance} button opens a specialized browser that displays all the methods overridden by the displayed method.
To see how it works, display the \cmind{ScaleMorph}{defaultColor} method and click \button{inheritance}.
This method definition overrides \mbox{\cmind{RectangleMorph}{defaultColor},} which itself overrides \cmind{Morph}{defaultColor}, as shown in \figref{inheritanceOverriding}.
The color of the \button{inheritance} button depends on how the \subind{method}{overriding} occurs.
The colors are explained in a help balloon:
\index{system browser!inheritance button}

%\newcommand{\colourTag}[1]{\item[{\mdseries \itshape #1}]}

%\begin{description}[noitemsep, leftmargin=*, labelindent=6em, labelwidth=4em, labelsep=*]
%	\colourTag{pink:} the displayed method overrides another method but doesn't use it;
%	\colourTag{green:} the displayed method overrides another method and uses it via \super;
%	\colourTag{gold:} the displayed method is itself overridden in a subclass;
%	\colourTag{salmon:} the displayed method overrides another method, and it itself overridden;
%	\colourTag{violet:} the displayed method overrides, is overridden, and makes a \ct{super}-send.
%\end{description}

\begin{tabular}{lp{9cm}}
	\emph{pink:} & the displayed method overrides another method but does not call super;\\
	\emph{green:} & the displayed method overrides another method and uses it via \super;\\
	\emph{tan:} & the displayed method is itself overridden in a subclass;\\
	\emph{mauve:} & the displayed method overrides another method, and it itself overridden;\\
	\emph{pink tan:} & the displayed method overrides, is overridden, and makes a \ct!super!-send.
\end{tabular}

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/inheritanceOverriding.png' frame: #morphs building: [:helper |
	self systemNavigation
		methodHierarchyBrowserForClass: ScaleMorph
		selector: #defaultColor.
	helper scaleWindow: helper foregroundWindow extent: 500 @ 250.
	helper selectAnyListIn: helper foregroundWindow at: '*Morph*'.
]
\end{ExecuteSmalltalkScript}
\begin{figure}[tbp]
	\begin{center}
   \ifluluelse
		{\includegraphics[width=\textwidth]{inheritanceOverriding}}
		{\includegraphics[scale=0.7]{inheritanceOverriding}}
	\end{center}
	\caption{\ct{ScaleMorph>>>defaultColor} and the methods that it overrides, in inheritance order.
	The \lct{inheritance} button is gold because the displayed method is overridden in a subclass.}
	\label{fig:inheritanceOverriding}
\end{figure}


\subsubsection{The hierarchy browser}
\label{sec:hierarchy}

The \button{hierarchy} button opens a \ind{hierarchy browser} on the current class; this browser can also be opened by using the \menu{browse hierarchy} menu item in the class pane.
The hierarchy browser is similar to the system browser, but instead of displaying the system categories and the classes in each category, it shows a single list of classes, indented to represent inheritance.
The category of the selected class is displayed in the small annotation pane at the top of the browser.
The hierarchy browser is designed to make it easy to navigate through the inheritance hierarchy, but does not show all of the classes in the system: only the superclasses and subclasses of the initial class are shown.
In \figref{hierarchyBrowser}, the hierarchy browser reveals that the direct superclass of \clsind{ScaleMorph} is \clsind{RectangleMorph}.
\index{system browser!hierarchy button}

\SqVersionSwitch{6.1}{
	\hint{Double-click on a class name in the hierarchy browser to add all of its subclasses to the class list.}
}{}

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/hierarchyBrowser.png' frame: #morphs building: [:helper |
	ScaleMorph browseHierarchy.
	helper scaleWindow: helper foregroundWindow extent: 600 @ 400.
]
\end{ExecuteSmalltalkScript}
\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{hierarchyBrowser}}
		{\includegraphics[scale=0.7]{hierarchyBrowser}}
	\end{center}
	\caption{A hierarchy browser open on \ct{ScaleMorph}.}
	\label{fig:hierarchyBrowser}
\end{figure}

\subsubsection{Finding variable or class references}
\label{sec:variables}

\index{system browser!variables button}
\index{system browser!references}
The \button{variables} button helps you find where an instance variable or a class variable is used; the same information is accessible from the \ind{yellow button} menu item \menu{references} in the class pane.
The menu also includes \menu{assignments}, which shows the subset of the instance variable references that assign to the variable.
Once you click on the button or select the menu item, you will be presented with a dialog that invites you to choose a variable from all of the variables defined in the current class, and all of the variables that it inherits.
The list is in inheritance order; it can often be useful to bring up this list just to remind yourself of the name of an instance variable.
If you click outside the list, it will go away and no variable browser will be created.

Another interesting action in the yellow button menu of the class pane is \menu{class refs (N)}, which displays a list of all of the methods that directly reference the current class.

\subsubsection{Source}
\label{sec:sources}

\index{system browser!source button}
The \button{source} button brings up the ``what to show'' menu, which allows you to choose what the browser shows in the source pane.  Options include the \menu{source} code, \menu{documentation}, \menu{prettyPrint}ed source code, \menu{show diffs}, \menu{byteCodes}, and source code \menu{decompile}d from the byte codes.
The label on the button changes if you select one of the other modes.
There are other options too; if you let the mouse linger over the names, a help balloon will appear.
Try some of them.
\index{method!pretty-print}
\index{method!decompile}
\index{method!byte code}

Note that selecting \menu{prettyPrint} in the ``what to show'' menu is \emph{not} the same as prettyPrinting a method before you save it.
The menu controls only what the browser displays, and does not affect the code stored in the system.
You can verify this by opening two browsers, and selecting \menu{prettyPrint} in one and \menu{source} in the other.
Focussing two browsers on the same method and selecting \menu{byteCodes} in one and \menu{decompile} in another is a good way to learn about the Squeak virtual machine's byte-coded instruction set.

%---------------------------------------------------------
\subsection{The browser menus}

Many additional functions are available from the browser's yellow button menu.
Since yellow button menus are context-sensitive,  each pane in the browser has its own menu.
Even if the labels on the menu items are the same, their \emph{meaning} depends on the context.
For example, the category pane, the class pane, the protocol pane, and the messages pane all have a \menu{file out} menu item.
However, they do different things:
The category pane's \menu{file out} menu files out the whole category, the class pane's \menu{file out} menu files-out the whole class, the protocol pane's \menu{file out} menu files out the whole protocol, and the method pane's \menu{file out} menu files-out just the displayed method.
Although this may seem obvious, it can be a source of confusion for beginners.
\index{file!filing in}
\index{file!filing out}

Possibly the most useful menu item for navigating is \menu{find class\ldots (f)} in the category pane.
Although the categories are useful for the code that we are actively developing, most of us do not know the categorization of the whole system, and it is much faster to type \short{f} followed by a few subsequent characters from the name of a class than to guess which category it might be in.
The find dialog also shows the classes that you have browsed recently, even if you have forgotten its name.
\index{class!finding}
\index{class!recent}

In the class pane, \menu{find method} is a similar menu item for browsing a particular method.
However, unless the list of methods is very long, it is often quicker to browse the \prot{-{}-all-{}-} protocol (which is the default), place the mouse in the method pane, and type the first letter of the name of the method that you are looking for.
This will filter the elements in the list so that the sought-for method name is visible.
\index{method!finding}
\protindex{all}

\dothis{Try both ways of navigating to \cmind{OrderedCollection}{removeAt:}}

There are many other options available in the menus.
It pays to spend a few minutes working with the browser and seeing what is there.

\dothis{Compare the result of the following three menu items in the class pane: \menu{Browse Protocol}, \menu{Browse Hierarchy}, and \menu{Show Hierarchy}.}

In general, the common navigation functions, such as searching for a class, browsing senders, or browsing implementors have keyboard shortcuts, which you can find in parentheses after the corresponding menu items.
Further, the feature that you can filter the list of methods by typing while having the list selected is a general feature of all lists in \sq.
Even in menus, such as the world menu, you can simply start typing to filter entries.

%---------------------------------------------------------
\subsection{Other class browsers}
\label{sec:otherBrowsers}

At the beginning of this section we mentioned another class browser: the \emphind{package pane browser}.
This browser can be opened from the world menu: \menu{World~\go{} open\ldots~\go{} package pane browser}
It's basically the same as the class browser, but it knows about the naming convention for system categories.
You will have noticed that the names of categories have two parts.
For example, the \ct{ScaleMorph} class belongs to the \scat{Morphic-Widgets} category.
\label{sec:package-names}
The package browser assumes that the part before the hyphen, \ct{Morphic}, is the name of a ``package'', and adds a fifth pane that allows you to browse only those categories in a particular package.
However, if you select no package at all, then all the categories are available, just as with the ordinary four-pane browser.
You can also open a package pane browser from a regular browser by yellow-clicking any system category on the left and choosing \menu{browse package}.

\SqVersionSwitch{6.1}{%
	We will describe packages in more detail in \secref{packages_and_monticello}.
}{% % http://lists.squeakfoundation.org/pipermail/squeak-dev/2022-September/222175.html
	Note that the meaning of the term \ind{package} as used in the package pane browser is different from the concept of Monticello packages.
	To browse all classes of a Monticello package, you can open a Snapshot Browser from the Monticello Browser by selecting a package and then pressing \button{Browse}.
}

%---------------------------------------------------------
\subsection{Browsing programmatically}

The class \glbind{SystemNavigation} provides a number of utility methods that are useful for navigating around the system.
Many of the functions offered by the classic browser are implemented by \ct{SystemNavigation}.
\index{browsing programmatically}

\dothis{
Open a workspace and \menu{do it} the following code to browse the senders of \ct{checkExtent:}:}
\begin{code}{}
SystemNavigation default browseAllCallsOn: #checkExtent:.
\end{code}
To restrict the search for senders to the methods of a specific class:
\begin{code}{}
SystemNavigation default browseAllCallsOn: #drawOn: from: ScaleMorph.
\end{code}
Because the development tools are objects, they are completely accessible from programs and you can develop your own tools or adapt the existing tools to your needs.

The programmatic equivalent to the \button{implementors} button is:
\begin{code}{}
SystemNavigation default browseAllImplementorsOf: #checkExtent:.
\end{code}

To learn more about what is available, explore the class \ct{SystemNavigation} with the browser.
Further navigation examples can be found in the FAQ (\appref{faq}).

Besides \ct{SystemNavigation}, there are also several subclasses of \clsind{Categorizer} that manage the categories in which classes or methods are organized.
In particular, a \clsind{ClassOrganizer} records the organization of methods in a class, and analogously, a \clsind{SystemOrganizer} records the organization of classes within system categories.
For example, you can retrieve all classes that are in the system category \ct{Collections-Strings} by sending \mthind{SystemOrganizer}{classesIn:} to the default \ct{SystemOrganizer} instance:
\begin{code}{@TEST}
SystemOrganizer default classesIn: 'Collections-Strings' --> an OrderedCollection(ByteString ByteSymbol Character String Symbol WideString WideSymbol)
\end{code}

\lr{Maybe mention how to change the default browser? SystemBrowser askForDefault (p. 141)}

%---------------------------------------------------------
\subsection{Summary}

As you have seen, there are many ways to navigate around Smalltalk code.
You may find this confusing at first, in which case you can always fall back to the traditional system browser.
However, we usually find that once beginners gain more experience with \sq, the availability of different browsers becomes one of its most valued features, because they provide many ways to help you to understand and organize your code.
The problem of understanding code is one of the greatest challenges of large-scale software development.
% section browser (end)

%=========================================================
\section{The inspector and the explorer}
\label{sec:inspector} % (fold)

One of the things that make \st so different from many other programming environments is that it provides you with a window onto a world of live objects, not a world of static code.
Any of those objects can be examined by the programmer, and even changed\,---\,although some care is necessary when changing the basic objects that support the system.
By all means experiment, but save your image first!

%---------------------------------------------------------
\subsection{The inspector}

\dothis{As an illustration of what you can do with an \ind{inspector}, type \ct{TimeStamp now} in a workspace, and then choose \menu{inspect it} from the \ind{yellow button} menu.
(It's not necessary to select the text before using the menu; if no text is selected, the menu operations work on the whole of the current line.
You can also type \short{i} for \menu{\textbf{i}nspect it}.)}
\clsindex{TimeStamp}
\index{keyboard shortcut!inspect it}

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/inspectTimeNow1.png' building: [:helper | | window splitter |
	TimeStamp now inspect.
	window := helper foregroundWindow.
	helper selectAnyListIn: helper foregroundWindow at: #utcMicroseconds.
	helper scaleWindow: window.
	splitter := window allMorphs detect: [:m |
		(m isKindOf: ProportionalSplitterMorph) and: [m splitsLeftAndRight]].
	splitter repositionBy: 50 @ 0
]
\end{ExecuteSmalltalkScript}
\begin{figure}[btp]
	\begin{center}
		\includegraphics[scale=0.65]{inspectTimeNow1}
	\end{center}
	\caption{Inspecting \ct{TimeStamp now}.}
	\label{fig:inspectTimeNow1}
\end{figure}

A window like that shown in \figref{inspectTimeNow1} will appear.
This is an inspector, and can be thought of as a window onto the internals of a particular object\,---\,in this case, the particular instance of \ct{TimeStamp} that was created when you evaluated the expression \ct{TimeStamp now}.
The title bar of the window shows the \emph{class} of the object that is being inspected.
If you select \menu{self} at the top of the left pane, the right pane will show the print string of the object.
If you select \menu{all inst vars} in the left pane, the right pane will show a list of the instance variables in the object, and the print string for each one.
The remaining items in the left pane represent the instance variables; this makes it easy to examine them one at a time, and also to change them.

The horizontal pane at the bottom of the inspector is a small workspace window.
In this window, the pseudo-variable \ct{self} is bound to the very object that you are inspecting.
So, if you \menu{inspect it} on
\begin{code}{}
self - TimeStamp today
\end{code}
in the workspace pane, the result will be a \clsind{Duration} object that represents the time interval between midnight today and the instant at which you evaluated \ct{TimeStamp now} and created the \ct{TimeStamp} object that you are inspecting.
You can also try evaluating \ct{TimeStamp now - self}; this will tell you how long you have spent reading this section of this book!

In addition to \ct{self}, all the instance variables of the object are in scope in the workspace pane, so you can use them in expressions or even assign values to them.
For example, if you evaluate \ct{localOffsetSeconds := localOffsetSeconds - 1} in the workspace pane, you will see that the value of the \ct{localOffsetSeconds} instance variable will indeed change, and the value of \ct{TimeStamp now - self} will increase by one second.

You can change instance variables directly by selecting them, replacing the old value in the right-hand pane by a Squeak expression, and accepting.
Squeak will evaluate the expression and assign the result to the instance variable.

There are many special variants of the inspector for different kinds of collections, methods, morphs, and a few other classes that make it easier to examine the contents of these special objects.
For instance, if you inspect an \ct{EllipseMorph} by doing \ct{EllipseMorph new openInWorld; inspect}, you will see a window like that shown in \figref{inspectMorph} that has special fields for accessing the geometry, the screenshot, and the properties of the ellipse.

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/inspectMorph.png' building: [:helper | | window splitter |
	EllipseMorph new openInWorld; inspect.
	helper selectAnyListIn: helper foregroundWindow at: #screenshot.
	window := helper foregroundWindow.
	window extent: 360 @ 270.
	splitter := window allMorphs detect: [:m |
		(m isKindOf: ProportionalSplitterMorph) and: [m splitsTopAndBottom]].
	splitter repositionBy: 0 @ 45.
	helper takeScreenshotOf: window.
]
\end{ExecuteSmalltalkScript}

\begin{figure}[btp]
	\begin{center}
		\includegraphics[scale=0.65]{inspectMorph}
	\end{center}
	\caption{Inspecting an \ct{ElipseMorph}.}
	\label{fig:inspectMorph}
\end{figure}

If you do a yellow-button click on any field in an inspector, you will see a menu of operations that can be performed on that field.
For instance, you can \menu{inspect} the value of the field, \menu{browse} its class, or search its implementation for all \menu{references} or \menu{assignments} to the selected variable.

You can also add your own fields to the inspector by using the \menu{add field...} menu item.
This concept is similar to what is known as \emph{watch expressions} in some other IDEs.
For instance, in the inspector of the \ct{EllipseMorph}, choose \menu{add field...}, type \ct{self position}, and \menu{accept}.
As you drag the ellipse around in the world, you will see the position of the ellipse change in the inspector.

%---------------------------------------------------------
\begin{ExecuteSmalltalkScript}"exploreTimeStampNow"
SBEScreenshotRecorder writeInto: './figures/' recordSeries: [:recorder |
	recorder writeTo: 'exploreTimeStampNow.png' building: [:helper |
		TimeStamp now explore.
		helper scaleWindow: helper foregroundWindow.
	].
	recorder writeTo: 'exploreTimeStampNow2.png' building: [:helper |
		| tree |
		tree := helper foregroundWindow findA: PluggableTreeMorph.
		helper
			select: tree
			at: 'localOffsetSeconds*'.
		tree toggleExpandedState: tree selectedMorph.
	].
]
\end{ExecuteSmalltalkScript}
\begin{figure}[tbp]
\begin{minipage}[t]{0.48\textwidth}
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{exploreTimeStampNow}}
		{\includegraphics[scale=0.7]{exploreTimeStampNow}}
	\end{center}
	\caption{Exploring \ct{TimeStamp now}.}
	\label{fig:exploreTimeStampNow}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{exploreTimeStampNow2}}
		{\includegraphics[scale=0.7]{exploreTimeStampNow2}}
	\end{center}
	\caption{Exploring the instance variables.}
	\label{fig:exploreTimeStampNow2}
\end{minipage}
\end{figure}

\subsection{The object explorer}

The \emph{object explorer} is conceptually similar to the inspector, but presents its information in a different way.
To see the difference, we'll \emph{explore} the same object that we were just inspecting.

\dothis{Select \menu{self} in the inspector's left-hand pane, and choose \menu{explore (I)} from the \ind{yellow button} menu.}
The \ind{explorer} window looks like \figref{exploreTimeStampNow}.
If you click on the small triangle next to \ct{root}, the view will change to \figref{exploreTimeStampNow2}, which shows the instance variables of the object that you are exploring.
Click on the triangle next to \ct{localOffsetSeconds}, and you will see \emph{its} instance variables. (Actually, in this example, \ct{hexadecimal}, \ct{octal}, \etc are no instance variables of the Integer object, but rather different representations.)
The explorer is really useful when you need to explore a complex hierarchic structure\,---\,hence the name.
\index{keyboard shortcut!explore it}

The workspace pane of the object explorer works slightly differently to that of the inspector.
\ct{self} is not bound to the root object, but rather to the object that is currently selected; the instance variables of the selected object are also in scope.

To see the value of the explorer, let's use it to explore a deeply-nested structure of objects.

\dothis{Open a browser, and blue-click twice on the method pane to bring-up the Morphic halo on the \ct{PluggableListMorph} that is used to represent the list of messages.
Click on the \emph{debug} handle \debugHandle{} and select \menu{explore morph}
from the menu that appears.  This will open an Explorer on the \clsind{PluggableListMorph} object that represents the method list on the screen.
Open the root object (by clicking in its triangle), open its \ct{submorphs}, and continue exploring the structure of the objects that underlie this Morph, as shown in \figref{explorePluggableListMorph}.}
\index{red button}

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/explorePluggableListMorph.png' building: [:helper |
	| lists tree |
	SystemBrowser defaultOpenBrowser.
	lists := (helper foregroundWindow submorphsSatisfying: #isPluggableListMorph)
		collect: [:list | list center x -> list] as: Dictionary.
	(lists at: lists keys max) explore.
	tree := helper foregroundWindow findA: PluggableTreeMorph.
	tree roots first openPathMatching: (#('root.*' 'submorphs.*' '1.*') collect: #asRegex).
	helper scaleWindow: helper foregroundWindow extent: 500 @ 350.
	helper takeScreenshotOf: helper foregroundWindow.
]
\end{ExecuteSmalltalkScript}
\begin{figure}[tbp]
	\begin{center}
		\includegraphics[scale=0.45]{explorePluggableListMorph}
	\end{center}
	\caption{Exploring a \ct{PluggableListMorph}.}
	\label{fig:explorePluggableListMorph}
\end{figure}

%=========================================================
\section{The debugger}
\label{sec:debugger} % (fold)

The \ind{debugger} is arguably the most powerful tool in the Squeak tool suite.
It is used not just for debugging, but also for writing new code.
To demonstrate the debugger, let's start by writing a bug!

\dothis{Using the browser, add the following method to the class \ct{String}:}

\needspace{10ex}
\begin{method}[buggy]{A buggy method.}
suffix
	"assumes that I'm a file name, and answers my suffix, the part after the last dot"

	| dot dotPosition |
	dot := FileDirectory dot.
	dotPosition := (self size to: 1 by: -1) detect: [:i | (self at: i) = dot].
	^ self copyFrom: dotPosition to: self size
\end{method}

Of course, we are sure that such a trivial method will work, so instead of writing an SUnit test, we just type \ct{'readme.txt' suffix} into a workspace and \menu{print it (p)}.
What a surprise!
Instead of getting the expected answer \ct{'txt'}, a \clsind{PreDebugWindow} pops up, as shown in \figref{PreDebugWindow}.

\begin{ExecuteSmalltalkScript}
"debuggers"
SBEScreenshotRecorder writeInto: './figures' recordSeries: [:recorder |
	| home debugger codePane contextVarList |
	home := thisContext.
	recorder writeTo: 'PreDebugWindow.png' building: [:helper |
		thisContext wrap: [:block | helper restoreMethods: {String >> #suffix} after: block].
		String compile: 'suffix
	"assumes that I''m a file name, and answers my suffix, the part after the last dot"
	| dot dotPosition |
	dot := FileDirectory dot.
	dotPosition := (self size to: 1 by: -1) detect: [ :i | (self at: i) = dot ].
	^ self copyFrom: dotPosition to: self size'
.
		helper
			runModal: ['readme.txt' suffix]
			then: [
				helper takeScreenshot.

				"Next screenshots"
				thisContext preponeSender: home.
			].
	].
	recorder writeTo: 'debuggerDetect.png' building: [:helper |
		helper click: (helper buttonLabeled: 'Debug*' in: helper foregroundWindow).
		debugger := helper foregroundWindow.
		helper scaleWindow: debugger.
		helper selectAnyListIn: debugger at: '*detect:ifFound:ifNone:'.
		codePane := helper textMorphIn: debugger withTextMatching: 'detect:*'.
		helper selectAnyListIn: debugger at: #self.
		helper focus: codePane.
	].
	recorder writeTo: 'RestartDetect.png' building: [:helper |
		helper click: (helper buttonLabeled: 'Restart*' in: debugger).
	].
	recorder writeTo: 'steppingIntoValue.png' building: [:helper |
		| stepThrough |
		stepThrough := helper buttonLabeled: 'Through*' in: debugger.
		contextVarList := helper listMorphIncludingMatch: #thisContext in: debugger.
		helper
			click: stepThrough;
			select: contextVarList at: #each;
			focus: codePane.
		[((debugger model instVarNamed: #contextVariablesInspector) object tempNamed: #each) > 7]
			whileTrue: [helper click: stepThrough].
	].
	recorder writeTo: 'dotIsAString.png' building: [:helper |
		helper
			click: (helper buttonLabeled: 'Into*' in: debugger);
			select: contextVarList at: #i;
			selectAnyListIn: debugger at: #self andScrollIntoViewBy: 1;
			focus: codePane.
	].
	recorder writeTo: 'revertDialog.png' building: [:helper |
		codePane setSelection: (1 to: 0).
		[codePane find]
			valueSupplyingAnswer: 'FileDirectory dot'.
		helper type: 'FileDirectory dot asCharacter' into: codePane.
		helper
			runModal: [codePane accept]
			then: [
				helper dialogWindow center: (debugger bounds pointAtFraction: 3 / 4 @ (4 / 11)).
				helper takeScreenshot].
	].
]
\end{ExecuteSmalltalkScript}
\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=0.7\textwidth]{PreDebugWindow}}
		{\includegraphics[scale=0.7]{PreDebugWindow}}
	\end{center}
	\caption{A \ct{PreDebugWindow} notifies us of a bug.}
	\label{fig:PreDebugWindow}
\end{figure}

The \ct{PreDebugWindow} has a title bar that tells us what error occurred, and shows us a \emphind{stack trace} of the messages that led up to the error.
Starting from the bottom of the trace, \ct{UndefinedObject>>>DoIt} represents the code that was compiled and run when we selected \ct{'readme.txt' suffix} in the workspace and asked \sq to \menu{print it}.
This code, of course, sent the message \ct{suffix} to a \clsind{ByteString} object (\ct{'readme.txt'}).
This caused the inherited \ct{suffix} method in class \ct{String} to execute; all this information is encoded in the next line of the stack trace, \ct{ByteString(String)>>>suffix}.
Working up the stack, we can see that \ct{suffix} sent \ct{detect:}\ldots and eventually \ct{detect:ifFound:ifNone:} sent \ct{errorNotFound}.
\clsindex{UndefinedObject}

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=0.9\textwidth]{debuggerDetect}}
		{\includegraphics[scale=0.7]{debuggerDetect}}
	\end{center}
	\caption{The debugger.}
	\label{fig:debuggerDetect}
\end{figure}

To find out \emph{why} the dot was not found, we need the debugger itself, so click on \button{Debug}.

\dothis{You can also open the debugger by clicking on any of the lines on the stack trace.
	If you do this, the debugger will open already focussed on the corresponding method.}

The debugger is shown in \figref{debuggerDetect}; it looks intimidating at first, but it is quite easy to use.
The title bar and the top pane are very similar to those that we saw in the \lct{PreDebugWindow}.
However, the debugger combines the stack trace with a method browser, so when you select a line in the stack trace, the corresponding method is shown in the pane below.
It's important to realize that the execution that caused the error is still in your image, but in a suspended state.
Each line of the stack trace represents a frame on the execution stack that contains all of the information necessary to continue the execution.
This includes all of the objects involved in the computation, with their instance variables, and all of the temporary variables of the executing methods.

In \figref{debuggerDetect} we have selected the \ct{detect:ifFound:ifNone:} method in the top pane.
The method body is displayed in the center pane; the blue highlight in the source code around the message \ct{value} shows that the current method has sent the message \ct{value} and is waiting for an answer.

The four panes at the bottom of the debugger are really two mini-inspectors (without workspace panes).
The inspector on the left shows the current object, that is, the object named \self in the center pane.
As you select different stack frames, the identity of \self may change, and so will the contents of the \self{}-inspector.
If you click on \self in the bottom-left pane, you will see that \self is the interval \ct{(10 to: 1 by: -1)}, which is what we expect.
The workspace panes are not needed in the debugger's mini-inspectors because all of the variables are also in scope in their value panes and in the method pane; you should feel free to type or select expressions in this pane and evaluate them.
You can always \menu{cancel (l)} your changes using the menu or \short{\textit{l}}.
% apb: that lower-case-L is in italics so that it doesn't look like a 1 or a |
\index{keyboard shortcut!cancel}

The inspector on the right shows the temporary variables of the current context.
In \figref{debuggerDetect}, \ct{value} was sent to the parameter \ct{exceptionBlock}.

\dothis{To see the current value of this parameter, click on \ct{exceptionBlock} in the context inspector.
This will tell you that \ct{exceptionBlock} is \ct{[self errorNotFound: ...]}.
So, it is not surprising that we see the corresponding error message.}

Incidentally, if you want to open a full inspector or explorer on one of the variables shown in the mini-inspectors, select the name of the variable and choose \menu{inspect (i)} or \menu{explore (I)} from the yellow button menu.
This can be useful if you want to watch how a variable changes while you execute other code.
\index{keyboard shortcut!inspect it}
\index{keyboard shortcut!explore it}

Looking back at the method window, we see that we expected the penultimate line of the method to find \ct{dot} in the string \ct{'readme.txt'}, and that execution should never have reached the final line.
\sq does not let us run an execution backward, but it does let us start a method again, which works very well in code such as this that does not mutate objects, but instead creates new ones.

\dothis{Click \button{Restart}, and you will see that the locus of execution returns to the first statement of the current method.
The blue highlight shows that the next message to be sent will be {\ct{do:}} (see \figref{RestartDetect}).}

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{RestartDetect}}
		{\includegraphics[scale=0.7]{RestartDetect}}
	\end{center}
	\caption{The debugger after restarting the \ct{detect:ifFound:ifNone:} method.}
	\label{fig:RestartDetect}
\end{figure}

The \button{Into} and \button{Over} buttons give us two different ways to step through the execution.
If you click \button{Over}, \sq executes the current message send (in this case the \ct{do:}) in one step, unless there is an error.
So \button{Over} will take us to the next message send in the current method, which is \ct{value}:
This is exactly where we started, and not much help.
What we need to do is to find out why the \ct{do:} is not finding the character that we are looking for.

\dothis{Click \button{Over}, and then click \button{Restart} to get back to the situation shown in \figref{RestartDetect}.}

\dothis{Click \button{Into}; \sq will go into the method corresponding to the highlighted message send, in this case, \ct{Collection>>>do:}.}

However, it turns out that this is not much help either:
We can be fairly confident that \ct{Collection>>>do:} is not broken.
The bug is much more likely to be in \emph{what} we asked \sq to do.
\button{Through} is the appropriate button to use in this case:
We want to ignore the details of the \ct{do:} itself and focus on the execution of the argument block.

\dothis{Click on \button{Through} a few times.
	Select \ct{each} in the context window as you do so.
	You should see \ct{each} count down from \ct{10} as the \ct{do:} method executes.}

When \ct{each} is \ct{7} we expect the \ct{ifTrue:} block to be executed because the dot is at position \ct{7}, but the \ct{ifTrue:} block is not executed.
To see what is going wrong, go \button{Into} the execution of \ct{value:} as illustrated in \figref{steppingIntoValue}.

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{steppingIntoValue}}
		{\includegraphics[scale=0.7]{steppingIntoValue}}
	\end{center}
	\caption{The debugger after stepping \lct{Through} the \ct{do:} method several times.}
	\label{fig:steppingIntoValue}
\end{figure}

After clicking \button{Into}, we find ourselves in the position shown in \figref{dotIsAString}.
It looks at first that we have gone \emph{back} to the \ct{suffix} method, but this is because we are now executing the block that \ct{suffix} provided as argument to \ct{detect:}.
If you select \ct{i} in the context inspector, you can see its current value, which should be \ct{7} if you have been following along.
You can then select the corresponding element of \self from the \self{}-inspector.
In \figref{dotIsAString} you can see that element \ct{7} of the string is character 46, which is indeed a dot.
If you select \ct{dot} in the context inspector, you will see that its value is \ct{'.'}.
And now you see why they are not equal: the seventh character of \ct{'readme.txt'} is a \ct{Character}, while \ct{dot} is a \ct{String}.

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{dotIsAString}}
		{\includegraphics[scale=0.7]{dotIsAString}}
	\end{center}
	\caption{The debugger showing why \ct{'readme.txt' at: 7} is not equal to \ct{dot}.}
	\label{fig:dotIsAString}
\end{figure}

Now that we see the bug, the fix is obvious: we have to convert \ct{dot} to a character before starting to search for it.

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{revertDialog}}
		{\includegraphics[scale=0.7]{revertDialog}}
	\end{center}
	\caption{Changing the \ct{suffix} method in the debugger: asking for confirmation of the exit from an inner block.}
	\label{fig:revertDialog}
\end{figure}

\dothis{Change the code right in the debugger so that the assignment reads \ct{dot := FileDirectory dot asCharacter} and \menu{accept} the change.}
Because we are executing code inside a block that is inside a \lct{detect:}, several stack frames will have to be abandoned in order to make this change.
\sq asks us if this is what we want (see \figref{revertDialog}), and, assuming that we click \menu{yes}, will save (and compile) the new method.

\dothis{Click \button{Restart} and then \button{Proceed}; the debugger window will vanish, and the evaluation of the expression \ct{'readme.txt' suffix} will complete, and print the answer \ct{'.txt'}}

\subsection{From the debugger to tests and back again}

Is the answer correct?
Unfortunately, we can't say for sure.
Should the suffix be \ct{.txt} or \ct{txt}?
The method comment in \ct{suffix} is not very precise.
A good way to avoid this kind of problem is to write an \ind{SUnit} test that defines the answer.
As you will see in the following example, we can also use the tests to advance our debugging sessions quickly.

We start by adding the following test method \mthref{testSuffix} to \ct{StringTest}.

\begin{method}[testSuffix]{A simple test for the \ct{suffix} method}
testSuffixFound

	self assert: 'txt' equals: 'readme.txt' suffix.
\end{method}

The effort required to do that was little more than to run the same code in the workspace, but by creating a test, we save the code as executable documentation, and make it easy for others to run.
Moreover, if you now run that test suite with \sunit, you can very quickly get back to debugging the error.
\sunit opens the debugger on the failing assertion, but you need only go back down the stack one frame, \button{Restart} the test and go \button{Into} the \ct{suffix} method, and you can correct the error, as we are doing in \figref{fixOffByOne}.
It is then only a second of work to click on the \button{Run Failures} button in the \sunit Test Runner, and confirm that the test now passes.

Here is a better test:

\begin{method}[testSuffix2]{A better test for the \ct{suffix} method.}
testSuffixFound

	self
		assert: 'txt' equals: 'readme.txt' suffix;
		assert: 'txt' equals: 'read.me.txt' suffix.
\end{method}
\noindent
Why is this test better?
Because it tells the reader what the method should do if there is more than one dot in the target \ct{String}.


\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/fixOffByOne.png' building: [:helper |
	| testRunner |
	thisContext wrap: [:block | helper restoreMethods: {
			String >> #suffix.
			StringTest >> #testSuffixFound.
			StringTest >> #testSuffixNotFound.
			StringTest >> #testShout.
			StringTest >> #testPercentEncodingJa. }
		after: block].
	String compile: 'suffix

"assumes that I''m a file name, and answers my suffix, the part after the last dot"
| dot dotPosition |
dot := FileDirectory dot asCharacter.
dotPosition := (self size to: 1 by: -1) detect: [:i | (self at: i) = dot].
^ self copyFrom: dotPosition to: self size'
.
	StringTest compile: 'testSuffixFound

self assert: ''txt'' equals: ''readme.txt'' suffix'
.
	StringTest compile: 'testShout'. "To prevent a failure from this test"
	StringTest removeSelector: #testSuffixNotFound.
	StringTest removeSelector: #testPercentEncodingJa. "very slow"
	testRunner := TestRunner newForSuite: StringTest suite.
	testRunner runAll.
	ToolBuilder open: testRunner.
	helper
		runModal: [ testRunner debugSuite: testRunner suiteAll ]
		then: [
			| debugger codePane |
			thisContext wrap: [:block | helper hideProgressMorphDuring: block].
			helper click: (helper buttonLabeled: 'debug*' in: helper foregroundWindow).
			debugger := helper foregroundWindow.
			helper scaleWindow: debugger.
			helper selectAnyListIn: debugger at: '*testSuffixFound'.
			codePane := helper textMorphIn: debugger withTextMatching: 'testSuffixFound*'.
			debugger model restart; stepInto.
			helper focus: codePane.
			codePane setSelection: (1 to: 0).
			[codePane find]
				valueSupplyingAnswer: 'dotPosition to:'.
			helper type: 'dotPosition + 1 to:' into: codePane.
			helper takeScreenshot].
]
\end{ExecuteSmalltalkScript}
\begin{figure}[btp]
	\begin{center}
		\includegraphics[width=\textwidth]{fixOffByOne}
	\end{center}
	\caption{Changing the \ct{suffix} method in the debugger: fixing the off-by-one error after an \sunit assertion failure.}
	\label{fig:fixOffByOne}
\end{figure}

That's all there is to our initial test, but it's not all there is to the \ct{suffix} method.
The initial bug should have made you realize that if there is no dot in the target string, the \ct{suffix} method will raise an error.
This isn't the behavior that we want, so let's add a second test to specify what should happen in this case.

\begin{method}[testNoSuffix]{A second test for the \ct{suffix} method: the target has no suffix.}
testSuffixNotFound

	self assert: '' equals: 'readme' suffix.
\end{method}

\needlines{2}
\dothis{Add \mthref{testNoSuffix} to the test suite in class \clsind{StringTest}, and watch the test raise an error.
Enter the debugger by selecting the erroneous test in \sunit, and edit the code so that the test passes.
The easiest and clearest way to do this is to replace the \ct{detect:} message by \ct{detect: ifNone:}, where the second argument is a block that simply returns the string size.}

\ab{When I wrote this I assumed that this chapter came after the one on Sunit; if we don't switch the order to make that true, this text needs to be adjusted or removed.}

We will learn more about SUnit in \charef{SUnit}.

\subsection{Ways into the debugger}

There are a few other ways to get into the debugger in addition to catching errors and assertion failures.
First of all, you can interrupt processes and open them in the debugger interactively.
If you execute code that goes into an infinite loop, you can interrupt it and open a debugger on the computation by typing \short{.} (that's a full stop or a period, depending on where you learned English).
You can also open a debugger on almost all running processes (see \secref{process-browser}). To do so, open the process browser and in the yellow button menu of a process, you can select to \menu{debug} it.

When you open a debugger on a computation interactively, you suspend the computation wherever it is at that moment.
Sometimes, you want to specify exactly at what point in the code you want to open a debugger.
Therefore, you edit the suspect code and insert \ct{self halt} at the point at which you want to open a debugger.
So, for example, we might edit the \ct{suffix} method to read as follows:
\index{process!interrupting}
\index{Object, \ct{halt}}
\seeindex{halt}{Object, \ct{halt}}
\seeindex{breakpoint}{Object, \ct{halt}}

\needspace{11ex}
\begin{method}[suffix]{Inserting a \ct{halt} into the \ct{suffix} method.}
suffix
	"assumes that I'm a file name, and answers my suffix, the part after the last dot"

	| dot dotPosition |
	dot := FileDirectory dot asCharacter.
	dotPosition := (self size to: 1 by: -1) detect: [:i | (self at: i) = dot].
	self halt.
	^ self copyFrom: dotPosition to: self size
\end{method}

When we run this method, the execution of the \ct{self halt} will bring up the \ind{pre-debugger}, from where we can proceed, or go into the debugger and look at variables, step the computation, and edit the code.

\paragraph{Advanced ways into the debugger}

Sometimes, a simple \ct{halt} can be problematic or insufficient. 
For these cases, there are some special ways to interrupt and inspect the execution.

For instance, when putting a \ct{halt} in code that restarts in another process whenever it is stopped, you would get an infinite number of debuggers.
In such a situation, we might only want to interrupt the execution once, let the execution restart in another process, and leave that new process alone.
For this use case, you can use \mthind{Object}{haltOnce}, which only interrupts the execution the first time it is executed. 
You can use it in source code just like \ct{halt}, but before you start your execution, you first have to do \ct{0 setHaltOnce}, which activates the \ct{haltOnce} (actually the receiver of \ct{setHaltOnce} does not matter, send it to whoever you want).
The corresponding message \mthind{Object}{inspectOnce} opens an inspector for whatever object the message was sent to and only does so once, again to save you from vast numbers of inspectors.

Another problem you might encounter while debugging is that the system encounters your \ct{halt} repeatedly, but you have to proceed many of the debuggers to find the point in time you are interested in.
For example, when you have a \ct{halt} in a loop working on the characters of a long string, you might only be interested in the loop iteration in which a separator is encountered, which unfortunately is the last third of the string.
To only interrupt the execution whenever a condition is met, for example, the separator character was read from the string, you can use \mthind{Object}{haltIf:}.
The method accepts a block that tests for the condition.

Finally, you can interactively set for which methods the execution should be interrupted.
You can do so in the yellow button menu on any list of methods via the option \menu{break on entry}.
When you activate it, a debugger will open every time an execution enters the method.

% section debugger (end)

%=========================================================
\section{The process browser}
\label{process-browser}

\st is a multi-threaded system: there are many lightweight processes (also known as threads) running concurrently in your image.
The \sq virtual machine implements concurrency by time-slicing.

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/processBrowser.png' building: [:helper |
	| processList stackList |
	ProcessBrowser open.
	helper scaleWindow: helper foregroundWindow.
	processList := helper selectAnyListIn: helper foregroundWindow at: '*the UI process*'.
	stackList := helper foregroundWindow findDeepSubmorphThat: [:m | m isPluggableListMorph and: [m ~= processList]] ifAbsent: [NotFound signal].
	stackList changeModelSelection: 1.
]
\end{ExecuteSmalltalkScript}
\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{processBrowser}}
		{\includegraphics[scale=0.7]{processBrowser}}
	\end{center}
	\caption{The process browser.}
	\label{fig:processBrowser}
\end{figure}

The process \subind{process}{browser} is a cousin of the debugger that lets you look at the various processes running inside \sq.
\figref{processBrowser} shows a screenshot.
The top-left pane lists all of the processes in \sq, in priority order, from the timer interrupt watcher at priority 80 to the idle process at priority 10.
Of course, on a uniprocessor, when you look which program is running, the only process that can be running is the UI process, as it is currently displaying the information to you; all of the other will be waiting for some kind of event.
By default, the display of processes is static; it can be updated using the \ind{yellow button} menu, which also provides an option to \menu{turn on auto-update (a)}

If you select a process in the top-left pane, its stack trace is displayed in the top-right pane, just as with the debugger.
If you select a stack frame, the corresponding method is displayed in the bottom pane.
The process browser is not equipped with mini-inspectors for \self and \lct{thisContext}, but yellow button menu items on the stack frames provide equivalent functionality.

\ab{I don't know what else to say about this; I've never used it.  Can someone add a scenario in which it is useful?}

\on{I guess we will come back to this when we get around to writing the chapter on concurrency!}

%=========================================================
\section{Finding methods}
\label{sec:methodFinder}

There are three tools in \sq to help you find messages. You can open the first two, \emph{method finder} and \emph{message names}, from \menu{World docking bar~\go{} Tools}. The third one is the global search in the right corner of the world docking bar.
They differ in both interface and functionality.

The \emph{method finder} was described at some length in \secref{quick:methodFinder}; you can use it to find methods by name or by functionality.
However, to look at the body of a method, the method finder opens a new browser.
This can quickly become overwhelming.

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/methodNamesRandom.png' building: [:helper |
	| methodList |
	(MessageNames methodBrowserSearchingFor: '*random*point*') openInWorld.
	helper scaleWindow: helper foregroundWindow.
	helper
		selectAnyListIn: helper foregroundWindow at: 'randomPoint:';
		selectAnyListIn: helper foregroundWindow at: 'Rectangle*'.
]
\end{ExecuteSmalltalkScript}
\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{methodNamesRandom}}
		{\includegraphics[scale=0.7]{methodNamesRandom}}
	\end{center}
	\caption{The method names browser showing all methods containing the substring \ct{random} in their selectors.}
	\label{fig:methodNamesRandom}
\end{figure}

\index{message names browser}
The \emph{message names} browser has more limited search functionality:
You type a fragment of a message selector in the search box, and the browser lists all methods that contain that fragment in their names, as shown in \figref{methodNamesRandom}.
Instead of the fragment, you can also specify a search term with wildcards (\ct{*} for zero or more characters, and \ct{#} for exactly one character).
However, it is a full-fledged browser:
If you select one of the names in the left pane, all of the methods with that name are listed in the right pane and can be browsed in the bottom pane.
As with the class browser, the message names browser has a button bar that can be used to open other  browsers on the selected method or its class.

\index{global method search}
The \emph{search bar} in the top right corner allows you to quickly access any method in the system.
You can either directly enter the full selector of the method, which will open a class browser, or enter a search term including wildcards, which will open a message names browser.
You can also use the search bar to search for classes also using wildcards.
As this search bar allows you to quickly jump to methods, it is also accessible via the keyboard shortcut \short{0}.


% section methodFinder (end)

%=========================================================
\section{Other interesting tools}
Beyond the common tools introduced in this chapter, \sq also provides a number of other interesting and rich tools.
We briefly introduce some of these tools which you might want to use when you are more proficient in using \sq:

\paragraph{Dependency browser}
Whenever you use a class in a method, the method then depends on the presence of this class.
If the class is not in the environment, running the method will result in an exception, as \sq does not know who should receive the message.
This is relevant, for example, whenever you use a class that is not part of the base system but stems from a project you installed.
Using the \ind{dependency browser} you can see the dependencies of your package.
You can open the dependency browser through \menu{world main docking bar~\go{} Apps~\go{} Dependency Browser} or from the context menu of a system category in a browser.

\paragraph{Lexicon}
Objects understand all messages for which their class or their superclasses have methods.
The system browser introduced earlier can only show you the methods of one class.
If you want to know all the methods an instance of a class understands you can open the \ind{lexicon}.
You can get the lexicon from the system browser by opening the yellow button menu for the class and selecting \menu{browse protocol (p)}.

\paragraph{Message tally}
Sometimes you might write code that is too slow.
The \ind{Message Tally} tool, sometimes also called \ind{profiler}, can help you to determine which parts of your program are slow.
You can start it to record the execution times for all processes in the image from the menu item \menu{world main docking bar~\go{} Extras~\go{} Start Profiler}.
Alternatively, you can also let it observe sections of code by selecting the code, opening the yellow button menu, and choosing \menu{spy on it}.
Note, that the message tally is a sampling profiler, so for detailed information, you will have to let your code run for some seconds (e.g. by running it 1000 times if it only takes little time).

%=========================================================
\section{Chapter summary}

In order to develop effectively with Squeak, it is important to invest some effort into learning the tools available in the environment.

\begin{itemize}
  \item The standard \emph{system browser} is your main interface for browsing existing class categories, classes, method protocols and methods, and for defining new ones.
  The system browser offers several useful buttons to directly jump to senders or implementors of a message, versions of a method, and so on.
  \item There exist several different class browsers (such as the System Browser and the Snapshot Browser from Monticello), and several specialized browsers (such as the hierarchy browser) which provide different views of classes and methods.
  \item From any of the tools, you can highlight the name of a class or a method and immediately jump to a browser by using the keyboard shortcut \short{b}.
  \item You can also browse the \st system programmatically by sending messages to \ct{SystemNavigation default}.
  \item The \emph{inspector} (\short{i}) and the \emph{explorer} (\short{I}) are two tools that are useful for exploring and interacting with live objects in your image.
  You can even inspect tools by blue-clicking to bring up their morphic halo and selecting the debug handle \debugHandle.
  \item The \emph{debugger} is a tool that not only lets you inspect the run-time stack of your program when an error is raised, but it also enables you to interact with all of the objects of your application, including the source code.
  In many cases, you can modify your source code from the debugger and continue executing.
  The debugger is especially effective as a tool to support test-first development in tandem with SUnit (\charef{SUnit}).
  \item The \emph{process browser} lets you monitor, query and interact with the processes that currently exist in your image.
  \item The \emph{method finder}, the \emph{message names browser}, and the \emph{search bar} are three tools for locating methods.
  The first is more useful when you are not sure of the name, but you know the expected behavior.
  The second offers a more advanced browsing interface when you know at least a fragment of the name.
  The third allows you to quickly navigate to methods.
\end{itemize}

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================

%=========================================================
%---------------------------------------------------------
