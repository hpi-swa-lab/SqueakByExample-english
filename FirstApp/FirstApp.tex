% $Author$
% $Date$
% $Revision$
%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.815in,.815in},
		vmargin={.98in,.98in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	\renewcommand{\nnbb}[2]{} % Disable editorial comments
\fi
%=================================================================
\chapter{Your first interactive object: the Quinto game}
\label{cha:firstApp}

In this chapter, we will develop a simple game: \ind{Quinto}.
Along the way, we will demonstrate most of the tools that \squeak programmers use to construct and debug their programs, and show how programs are exchanged with other developers.
We will see the system browser, the object inspector, the debugger, and the \ind{Monticello} \ind{package} browser.
Development in Smalltalk is efficient:
You will find that you spend far more time actually writing code and far less managing the development process.
This is partly because the Smalltalk language is simple, and partly because the tools that make up the programming environment are integrated well with the language.

Nevertheless, if you find yourself not understanding all of the code, don't worry.
We will explain the details of the syntax, the object model, and message passing in later chapters.

%=================================================================
\section{The Quinto game}

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/GameBoard.png' frame: #morphs building: [:helper |
	| game |
	game := SBEGame new openInWorld.

	self flag: #workaround. "SBECell's fullBounds > SBECell's bounds because the empty label has a larger extent. In high-dpi mode, this leads to huge protuding spacing."
	game submorphsDo: [:cell | cell firstSubmorph "label" delete].

	game addFlexShell
		scale: RealEstateAgent scaleFactor;
		openInWorld.

	helper click: game at: (game boundsInWorld pointAtFraction: 4 @ 6 - 0.5 / 10) buttons: #(left).
	helper spawnHand.
]
\end{ExecuteSmalltalkScript}
\begin{figure}[ht]
	\vskip -\baselineskip
	\centerline{\includegraphics[width=.33\linewidth]{GameBoard}}
	\caption{The Quinto game board. The user has just clicked the mouse as shown by the cursor.
	\label{fig:gameBoard}}
\end{figure}

To show you how to use \squeak's programming tools, we will build a simple game called \emph{Quinto}.
The game board is shown in \figref{gameBoard}. The board consists of a rectangular grid of light yellow \emph{cells}.
When you click on one of the cells with the mouse, the four surrounding cells turn blue, but not the cell you clicked on.
Click again, and the surrounding cells toggle back to light yellow.
The objective of the game is to turn as many cells as possible to blue.

The Quinto game shown in \figref{gameBoard} is made up of two kinds of objects: the game board itself, and 100 individual cell objects.
The \squeak code to implement the game will contain two classes: one for the game and one for the cells.
We will now show you how to define these classes using the \squeak programming tools.

%=================================================================
\section{Creating a new class category}

We have already seen the \ind{system browser} in \charef{quick}, where we learned how to navigate to classes and methods, and saw how to define new methods.
Now we will see how to create system categories and classes.
\seeindex{system category}{category}
\seeindex{class category}{system category}
\index{category!creating}

\dothis{Open a system browser and yellow-click in the category pane.
Select \menu{add item \ldots}.}

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/AddCategory.png' frame: [:bounds | bounds * (0 asPoint corner: 0.4 @ 0.75)] building: [:helper |
	| window |
	SystemBrowser defaultOpenBrowser.
	window := helper foregroundWindow.
	helper click: window at: window topLeft + (50 px @ 40 px) buttons: #(right).
	helper hand releaseMouseFocus.
	helper mouseEnter: (helper menuItemMorphLabeled: 'add item*' in: helper world).
	helper closeBalloons.
]
\end{ExecuteSmalltalkScript}
\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/ClassTemplate.png' frame: [:bounds | bounds * (0 asPoint corner: 0.4 @ 0.75)] building: [:helper |
	thisContext wrap: [:block |
		helper emptyOrganizer: self environment organization atCategory: 'SBE-Quinto' during: block].

	ToolSet browseCategory: 'SBE-Quinto'.
	helper takeScreenshot.
]
\end{ExecuteSmalltalkScript}
\begin{figure}[htb]
\begin{minipage}[b]{0.48\textwidth}
\ifluluelse
	{\centerline {\includegraphics[width=0.9\textwidth]{AddCategory}}}
	{\centerline {\includegraphics[scale=0.7]{AddCategory}}}
	\caption{Adding a system category.
	\label{fig:addCategory}}
\end{minipage}
\hfill
\begin{minipage}[b]{0.48\textwidth}
\ifluluelse
	{\centerline {\includegraphics[width=0.9\textwidth]{ClassTemplate}}}
	{\centerline {\includegraphics[scale=0.7]{ClassTemplate}}}
	\caption{The class-creation template.
	\label{fig:classTemplate}}
\end{minipage}
\end{figure}

Type the name of the new category (we will use \scat{SBE-Quinto}) in the dialog box and click \menu{accept} (or just press the return key); the new category is created, and positioned at the end of the category list.
If you selected an existing category first, then the new category will be positioned immediately ahead of the selected one.

%=================================================================
\section{Defining the class SBECell}

As yet there are  of course no classes in the new category.
However, the main editing pane displays a template to make it easy to create a new class (see \figref{classTemplate}).
This template shows us a \st expression that sends a message to a class called \ct{Object}, asking it to create a subclass called \ct{NameOfSubClass}.
The new class has no variables and should belong to the category \scat{SBE-Quinto}.
We now modify the template to create the class that we want.

\dothis{Modify the class creation template as follows:}
\begin{itemize}
  \item Replace \clsind{Object} by \clsind{SimpleSwitchMorph}.
  \item Replace \ct{NameOfSubClass} by \clsind{SBECell}.
  \item Add \ct{mouseAction} to the list of instance variables.
\end{itemize}
The result should look like \clsref{firstClassDef}.

\begin{classdef}[firstClassDef]{Defining the class \ct| SBECell|.}
SimpleSwitchMorph subclass: #SBECell
   instanceVariableNames: 'mouseAction'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'SBE-Quinto'
\end{classdef}
\index{system browser!defining a class}
\index{class!creation}
\index{Morphic}

This new definition consists of a \st expression that sends a message to the existing class \ct{SimpleSwitchMorph}, asking it to create a subclass called \ct{SBECell}.
(Actually, since \ct{SBECell} does not exist yet, we passed as an argument the \emphind{symbol} \ct{#SBECell} which stands for the name of the class to create.)
We also tell it that instances of the new class should have a \ct{mouseAction} instance variable, which we will use to define what action the cell should take if we click on it.

\emph{At this point, you still have not created anything.}
Note that in the upper right corner of the class template pane a red triangle appeared (\figref{acceptClassDef}).
This means that there are \emph{unsaved changes}.
To actually send this message, you must \menu{accept} it.

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/AcceptClassDef.png' frame: [:rect | rect bottomHalf] building: [:helper |
	| window codePane menu |
	SBECell browse.
	window := helper foregroundWindow.
	window bounds: (0 px @ 120 px extent: 500 px @ 400 px).
	codePane := helper codePaneOfBrowser: window.
	codePane hasUnacceptedEdits: true.
	helper click: window at: codePane center buttons: #(right).
	helper closeBalloons.
	menu := helper foregroundMorph.
	menu bottomRight: window bottomRight - (50 px @ 35 px).
	helper hand releaseMouseFocus.
	helper mouseEnter: (helper menuItemMorphLabeled: 'accept*' in: helper world).
]
\end{ExecuteSmalltalkScript}
\begin{figure}[h!t]
\ifluluelse
	{\centerline {\includegraphics[width=\textwidth]{AcceptClassDef}}}
	{\centerline {\includegraphics[scale=0.7]{AcceptClassDef}}}
\caption{The class-creation template.
\label{fig:acceptClassDef}}
\end{figure}

\dothis{Accept the new class definition.}
Either yellow-click and select \menu{accept}, or use the shortcut \short{s} (for ``save'').
The message will be sent to \ct{SimpleSwitchMorph}, which will cause the new class to be compiled.
\index{yellow button}
\index{keyboard shortcut!accept}

Once the class definition is accepted, the class will be created and appear in the classes pane of the browser (\figref{SBECell}).
The editing pane now shows the class definition, and a small pane below it will remind you to write a few words describing the purpose of the class.
This is called a \emph{class comment}, and it is quite important to write one that will give other programmers a high-level overview of the purpose of this class.
Smalltalkers put a very high value on the readability of their code, and detailed comments about the content of a method are unusual:
The philosophy is that the code should speak for itself.
(If it doesn't, you should refactor it until it does!)
Be aware that this refers to the content of the method, not the purpose of the method in the larger system or assumptions of the method; these aspects should definitely be described in a method or class comment.
A class \subind{class}{comment} need not contain a detailed description of the implementation details of the class, but a few words describing its overall purpose are vital if programmers who come after you are to know whether to spend time looking at this class.
\index{refactoring}

\dothis{Type a class comment for \ct{SBECell} and accept it; you can always improve it later.}

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/SBECell.png' frame: #morphs building: [:helper |
	thisContext wrap: [:block |
		helper emptyOrganizer: self environment organization atCategory: 'SBE-Quinto' during: block].
	self environment organization classify: SBECell name under: 'SBE-Quinto'.
	thisContext wrap: [:block |
		helper emptyClass: SBECell during: block].

	SBECell browse.
	helper takeScreenshot.
]
\end{ExecuteSmalltalkScript}
\begin{figure}[h!t]
\ifluluelse
	{\centerline {\includegraphics[width=\textwidth]{SBECell}}}
	{\centerline {\includegraphics[scale=0.7]{SBECell}}}
\caption{The newly-created class \ct{SBECell}\label{fig:SBECell}.}
\end{figure}

%=================================================================
\section{Adding methods to a class}

Now let's add some methods to our class.

\dothis{Select the protocol \prot{-{}-all-{}-} in the protocol pane.}
You will see a template for method creation in the editing pane.
Select it, and replace it by the text of \mthref{scbecellinitialize}.
\protindex{all}
\index{method!creation}
\index{system browser!defining a method}

\needlines{10}
\numFiletreeMethodInput[scbecellinitialize]%
{Initializing instances of \ct{SBECell}.}%
{ListingSources/SBE-Quinto.package/SBECell.class/instance/initialize.st}
\index{initialization}

\noindent
Note that the characters \ct{''} on line 3 are two separate single quotes with nothing between them, not a double quote!
\ct{''} denotes the empty string.

\dothis{\menu{Accept} this method definition.}

What does the above code do?
We won't go into all of the details here (that's what the rest of the book is for!), but we will give you a quick preview.
Let's take it line by line.

Notice that the method is called \mthind{SBECell}{initialize}.
This name has a special meaning.
By convention, if a class defines a method named \ct{initialize}, it will be called right after the object is created.
So, when we evaluate \ct{SBECell new}, the message \ct{initialize} will be sent automatically to this newly created object.
Initialize methods are used to set up the state of objects, typically to set their instance variables; this is exactly what we are doing here.
\seeindex{Object!initialization}{initialization}
\index{initialization}

The first thing that this method does (line 2) is to execute the \ct{initialize} method of its superclass, \ct{SimpleSwitchMorph}.
The idea here is that any inherited state will be properly initialized by the \ct{initialize} method of the superclass.
It is always a good idea to initialize inherited state by sending \ct{super initialize} before doing anything else; we don't know exactly what \ct{SimpleSwitchMorph}'s \ct{initialize} method will do, and we don't care, but it's a fair bet that it will set up some instance variables to hold reasonable default values, so we had better call it, or we risk starting in an unclean state.

The rest of the method sets up the state of this object.
Sending \ct{self label: ''}, for example, sets the label of this object to the empty string.
\pvindex{self}

The expression \ct{0 @ 0 corner: 16 @ 16} probably needs some explanation.
\lct{0 @ 0} represents a \clsind{Point} object with $x$ and $y$ coordinates both set to 0.
In fact, \ct{0 @ 0} sends the message \ct{@} to the \clsind{Number} object \ct{0} with argument \ct{0}.
The effect will be that the number \ct{0} will ask the \ct{Point} class to create a new instance with coordinates $(0,0)$.
Now we send this newly created point the message \ct{corner: 16 @ 16}, which causes it to create a \clsind{Rectangle} with corners \ct{0 @ 0} and \ct{16 @ 16}.
We use the setter method \ct{bounds}, inherited from the superclass, to set the \ct{bounds} of the cell to the newly created rectangle.

Note that the origin of the \sq screen is the \emph{top left}, and the $y$ coordinate increases \emph{downward}.

The rest of the method should be self-explanatory.
Part of the art of writing good \st code is to pick good method names so that \st code can be read like a kind of pidgin English.
You should be able to imagine the object talking to itself and saying ``\ct{Self use square corners!}'', ``\ct{Self turn off!}''.

%=================================================================
\section{Inspecting an object}

You can test the effect of the code you have written by creating a new \ct{SBECell} object and inspecting it.

\dothis{Open a workspace.
	Type the expression \ct{SBECell new} and \menu{inspect it}.}

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/SBECellInspector.png' frame: #morphs building: [:helper |
	| window pane |
	SBECell new inspect.
	window := helper foregroundWindow.
	helper scaleWindow: window.
	pane := helper listMorphIncludingMatch: #bounds in: window.
	pane changeModelSelection: 3.
	window lookFocused.
]
\end{ExecuteSmalltalkScript}
\begin{figure}[htbp]
   \centering
   \includegraphics[width=0.55\textwidth]{SBECellInspector}
   \caption{The inspector used to examine a SBECell object.\label{fig:SBECellInspector}}
\end{figure}

The left-hand pane of the \ind{inspector} shows a list of instance variables; if you select one (try \mbox{\ct{bounds}),} the value of the \ind{instance variable} is shown in the right pane.
You can also use the inspector to change the value of an instance variable.

\dothis{Change the value of \ct{bounds} to \ct{0 @ 0 corner: 50 @ 50} and \menu{accept} it.}

The bottom pane of the inspector is a mini-workspace.
It's useful because in this workspace the pseudo-variable \self is bound to the object being inspected.

\dothis{Type the text \ct{self openInWorld} in the bottom pane and \menu{do it}.}
The cell should appear at the top left-hand corner of the screen, indeed, exactly where its \ct{bounds} say that it should appear.
Blue-click on the cell to bring up the morphic \subind{Morphic}{halo}.
Move the cell with the brown (next to top-right) handle and resize it with the yellow (bottom-right) handle.
Notice how the bounds reported by the inspector also change.

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/SBECellResize.png' frame: #morphs building: [:helper |
  | cell window list bottomPane |
  cell := SBECell new.
  cell inspect.
  window := helper foregroundWindow.
  list := helper listMorphIncludingMatch: #bounds in: window.
  list changeModelSelection: 3.
  bottomPane := window findDeepSubmorphThat: [:m | m isTextView and: [m text isEmptyOrNil]] ifAbsent: [self error: 'bottom pane not found'].
  bottomPane setText: 'self openInWorld'; doIt.
  cell position: 100 px @ 100 px; extent: 98 px @ 89 px.
  window position: 350 px @ 50 px.
  cell addHalo.
  (NewBalloonMorph string: 'Change size' for: cell) popUpAt: cell bottomRight + 31 px.
]
\end{ExecuteSmalltalkScript}
\begin{figure}[htbp]
\centering
\ifluluelse
	{\includegraphics[width=0.8\textwidth]{SBECellResize} }
	{\includegraphics[scale=0.7]{SBECellResize} }
\caption{Resizing the cell.\label{fig:cellresize}}
\end{figure}

\dothis{Delete the cell by clicking on the \ct{x} in the pink handle.}


%=================================================================
\section{Defining the class SBEGame}

Now let's create the other class that we need for the game, which we will call \clsind{SBEGame}.

\dothis{Make the class definition template visible in the browser's main window.}
Do this by clicking twice on the name of the already-selected class category, or by displaying the definition of \ct{SBECell} again (by clicking the \button{instance} button.)
Edit the code so that it reads as follows, and \menu{accept} it.

\needlines{6}
\begin{classdef}[sbegame]{Defining the \ct{SBEGame} class}
BorderedMorph subclass: #SBEGame
   instanceVariableNames: ''
   classVariableNames: ''
   poolDictionaries: ''
   category: 'SBE-Quinto'
\end{classdef}

Here we subclass \clsind{BorderedMorph}; \clsind{Morph} is the superclass of all of the graphical shapes in \squeak, and (surprise!) a \ct{BorderedMorph} is a \ct{Morph} with a border.
We could also insert the names of the instance variables between the quotes on the second line, but for now, let's just leave that list empty.

Now let's define an \mthind{SBEGame}{initialize} method for \ct{SBEGame}.

\dothis{Type the following into the browser as a method for \ct{SBEGame} and try to \menu{accept} it:}

\needlines{9}
\numFiletreeMethodInput[sbegameinitialize]%
{Initializing the game.}%
{ListingSources/SBE-Quinto.package/SBEGame.class/instance/initialize.st}

%\sd{it would be nicer if we would not have to create an instance of SBECell for nothing}
%\on{yes}

\squeak will complain that it doesn't know the meaning of some of the terms.
\squeak tells you that it doesn't know of a message \ct{cellsPerSide}, and suggests a number of corrections, in case it was a spelling mistake.


\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/UnknownSelector.png' frame: #morphs building: [:helper |
	thisContext wrap: [:block | helper forgetSymbol: #cellsPerSide during: block].
	helper runModal: [UnknownSelector name: #cellsPerSide]
]
\end{ExecuteSmalltalkScript}
\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/DeclareInstanceVar.png' frame: #morphs building: [:helper |
	helper
		runModal: [Compiler new
			compile: 'initialize cells'
			in: Object
			environment: SBEGame environment
			notifying: PluggableTextMorph new
			ifFail: []]
 		then: [helper select: helper dialogWindow at: '*instance*']
]
\end{ExecuteSmalltalkScript}
\begin{figure}[htb]
\begin{minipage}[t]{0.42\textwidth}
	\centering
	\ifluluelse
		{\includegraphics[width=0.8\textwidth]{UnknownSelector}}
		{\includegraphics[scale=0.7]{UnknownSelector}}
	\caption{\squeak detecting an unknown selector.\label{fig:unknownSelector}}
\end{minipage}
\hfill
\begin{minipage}[t]{0.56\textwidth}
	\centering
	\ifluluelse
		{\includegraphics[width=0.6\textwidth]{DeclareInstanceVar}}
		{\includegraphics[scale=0.7]{DeclareInstanceVar}}
	\caption{Declaring a new instance variable.\label{fig:declareInstance}}
\end{minipage}
\end{figure}

But \ct{cellsPerSide} is not a mistake\,---\,it is just a method that we haven't yet defined\,---\,we will do so in a minute or two.

\dothis{So just select the first item from the menu, which confirms that we really meant \ct{cellsPerSide}.}

Next, \squeak will complain that it doesn't know the meaning of \ct{cells}.
It offers you a number of ways of fixing this.

\dothis{Choose \menu{declare instance} because we want \ct{cells} to be an instance variable.}
Finally, \squeak will complain about the message \ct{newCellAt:at:} sent on the last line; this is also not a mistake, so confirm that message too.
\index{on the fly variable definition}
\index{instance variable definition}

If you now look at the class definition once again (which you can do by clicking on the \button{instance} button), you will see that the browser has modified it to include the instance variable \ct{cells}.

Let's look at our \ct{initialize} method.
The line \ct{|height overallBorderWidth sampleCell width|}  declares 4 temporary variables.
They are called temporary variables because their scope and lifetime are limited to this method.
Temporary variables with explanatory names are helpful in making code more readable.
Smalltalk has no special syntax to distinguish constants and variables, and in fact all four of these ``variables'' are really constants.
Lines 5--7 define these constants.

How big should our game board be?
Big enough to hold some integral number of cells, and big enough to draw a border around them.
How many cells is the right number?
5? 10? 100?
We don't know yet, and if we did, we would probably change our minds later.
So we delegate the responsibility for knowing that number to another method, which we will call \ct{cellsPerSide}, and which we will write in a minute or two.
It's because we are sending the \ct{cellsPerSide} message before we define a method with that name that \squeak asked us to ``confirm, correct, or cancel'' when we accepted the method body for \ct{initialize}.
Don't be put off by this:
It is actually good practice to write in terms of other methods that we haven't yet defined.
Why?
Well, it wasn't until we started writing the \ct{initialize} method that we realized that we needed it, and at that point, we can give it a meaningful name, and move on, without interrupting our flow.

The lines 4--6 create a new \ct{SBECell} object, and assign its width and height to the appropriate temporary variables.

Line 8 sets the \ct{extent} of the new object.
Without worrying too much about the details just yet, just believe us that the expression in parentheses creates a square with its origin (\ie its top-left corner) at the point $(5,5)$ and its bottom-right corner far enough away to allow space for the right number of cells.

The last line sets the \ct{SBEGame} object's instance variable \ct{cells} to a newly created \clsind{Matrix} with the right number of rows and columns.
We do this by sending the message \ct{new:tabulate:} to the \ct{Matrix} class (classes are objects too, so we can send them messages).
We know that \mthind{Matrix class}{new:tabulate:} takes two arguments because it has two colons (\ct{:}) in its name.
The arguments go right after the colons.
If you are used to languages that put all of the arguments together inside parentheses, this may seem weird at first.
Don't panic, it's only syntax!
It turns out to be a very good syntax because the name of the method can be used to explain the roles of the arguments.
For example, it is pretty clear that \ct{Matrix rows: 5 columns: 2} has 5 rows and 2 columns, and not 2 rows and 5 columns.
\cmindex{Matrix class}{rows:columns:}

\ct{Matrix new: self cellsPerSide tabulate: [:i :j | self newCellAt: i at: j]} creates a new \ct{n}{$\times$}\ct{n} matrix and initializes its elements.
The initial value of each element will depend on its coordinates.
The {$(i,j)$}\textsuperscript{th} element will be initialized to the result of evaluating \ct{self newCellAt: i at: j}.

%=================================================================
\section{Organizing methods into protocols}

Before we define any more methods, let's take a quick look at the third pane at the top of the browser.
In the same way that the first pane of the browser lets us categorize classes so we are not overwhelmed by a very long list of class names in the second pane, so the third pane lets us categorize methods so that we are not overwhelmed by a very long list of method names in the fourth pane.
These categories of methods are also called ``protocols''.
\index{protocol}

If there are only a few methods in a class, the extra level of hierarchy provided by protocols is not really necessary.
This is why the browser also offers us the \prot{-{}-all-{}-} virtual protocol, which, you will not be surprised to learn, contains all of the methods in the class.
\protindex{all}

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/Categorize.png' frame: [:bounds | bounds * (1 @ 0 rect: 1 @ 3 / 4)] building: [:helper |
	| window |
	thisContext wrap: [:block |
		helper emptyClass: SBEGame during: block].
	SBEGame organization classify: #initialize under: SBEGame organization class default.

	ToolSet browseClass: SBEGame.
	window := helper foregroundWindow.
	window bounds: (0 px @ 120 px extent: 600 px @ 350 px).
	helper click: window at: window topCenter + (30 px @ 60 px) buttons: #(right).
	helper menu top: helper menu top + 10.
	helper hand releaseMouseFocus.
	helper mouseEnter: (helper menuItemMorphLabeled: 'categorize all uncategorized' in: helper world).
	helper closeBalloons.
	helper takeScreenshot.
]
\end{ExecuteSmalltalkScript}
\begin{figure}[htbp]
   \includegraphics[width=0.65\textwidth]{Categorize}
   \caption{Categorize all uncategorized methods.\label{fig:categorize}}
\end{figure}

If you have followed along with this example, the third pane may well contain the protocol \protind{as yet unclassified}.

\dothis{Select the \ind{yellow button} menu item \menu{categorize all uncategorized} to fix this, and the \ct{initialize} method will be moved to a new protocol called \protind{initialization}.}
How does \squeak{} know that this is the right protocol?
Well, in general \squeak{} can't know, but in this case, there is also an \ct{initialize} method in a superclass, and \squeak assumes that our \ct{initialize} method should go in the same protocol as the one that it overrides.
\index{method!categorize}

\paragraph{A typographic convention.}
Smalltalkers frequently use the notation ``\verb|>>|'' to identify the class to which a method belongs, so, for example, the \ct{cellsPerSide} method in class \ct{SBEGame} would be referred to as \ct{SBEGame>>cellsPerSide}.
To indicate that this is \emph{not} \st syntax, we will use the special symbol \ct{>>>} instead, so this method will appear in the text as \ct{SBEGame>>>cellsPerSide}.
\cmindex{Behavior}{>>}
From now on, when we show a method in this book, we will write the name of the method in this form.
Of course, when you actually type the code into the browser, you don't have to type the class name or the \ct{>>>}; instead, you just make sure that the appropriate class is selected in the class pane.

Now let's define the other two methods that are used by the \ct{SBEGame>>>initialize} method.
Both of them can go in the \prot{initialization} protocol.

\numFiletreeMethodInput[sbegamecellsperside]%
{A constant method.}%
{ListingSources/SBE-Quinto.package/SBEGame.class/instance/cellsPerSide.st}
\cmindex{SBEGame}{cellsPerSide}
\index{constant methods}

This method could hardly be simpler:
It answers the constant 10.
One advantage of representing constants as methods is that if the program evolves so that the constant then depends on some other features, the method can be changed to calculate this value.

\needlines{10}
\begin{method}[newCellAt:at:]{An initialization helper method.}
SBEGame>>>newCellAt: i at: j
	"Create a cell for position (i,j) and add it to my on-screen
	representation at the appropriate screen position. Answer the new cell."

	| cell origin |
	cell := SBECell new.
	origin := self innerBounds origin.
	self addMorph: cell.
	cell
		position: ((i - 1) * cell width) @ ((j - 1) * cell height) + origin;
		mouseAction: [self toggleNeighboursOfCellAt: i at: j].
\end{method}
\cmindex{SBEGame}{newCellAt:at:}

\dothis{Add the methods \ct{SBEGame>>>cellsPerSide} and \ct{SBEGame>>>newCellAt:at:}.}
Confirm the spelling of the new selectors \ct{toggleNeighboursOfCellAt:at:} and \ct{mouseAction:}.

\Mthref{newCellAt:at:} answers a new SBECell, specialized to position \ct{(i, j)} in the \clsind{Matrix} of cells.
The last line defines the new cell's \ct{mouseAction} to be the \emph{block}
\mbox{\lct{[self toggleNeighboursOfCellAt: i at: j ]}.}
In effect, this defines the callback behavior to perform when the mouse is clicked.
The corresponding method also needs to be defined.

\numFiletreeMethodInput[toggleNeighboursOfCellAt:at:]%
{The callback method.}%
{ListingSources/SBE-Quinto.package/SBEGame.class/instance/toggleNeighboursOfCellAt.at..st}
\cmindex{SBEGame}{toggleNeighboursOfCellAt:at:}

\Mthref{toggleNeighboursOfCellAt:at:} toggles the state of the four cells to the north, south, west and east of cell $(i, j)$.
The only complication is that the board is finite, so we have to make sure that a neighboring cell exists before we toggle its state.

\dothis{Place this method in a new protocol called \prot{game logic}.
	To create the protocol, press the yellow mouse button in the protocol list, select \menu{new category\ldots}, enter ``game logic'', and submit the dialog.}
To move the method, you can simply click on its name and drag it to the newly-created protocol (\figref{dragMethod}).

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/DragMethod.png' frame: [:rectangle | rectangle withHeight: rectangle height * 2 / 3] building: [:helper |
	| window messageList categoryList |
	SBEGame browse.
	window := helper foregroundWindow.
	window extent: 600 px @ 300 px.
	messageList := helper morphByExternalName: #messageList in: window.
	categoryList := helper morphByExternalName: #messageCategoryList in: window.
	helper
		mouseDrag: messageList
		from: (helper boundsOfItemMatching: #toggleNeighboursOfCellAt:at: in: messageList) center
		to: ((helper boundsOfItemMatching: 'game logic' in: categoryList) pointAtFraction: 0 @ 0.75) + (10 "must not depend on width of item which may be infinite in tree browser" @ 0)
		buttons: #(left).
	helper spawnHand.
]
\end{ExecuteSmalltalkScript}
\begin{figure}[htbp]
   \centering
   \ifluluelse
		{\includegraphics[width=\textwidth]{DragMethod} }
		{\includegraphics[scale=0.7]{DragMethod} }
	\caption{Drag a method to a protocol.\label{fig:dragMethod}}
\end{figure}

To complete the Quinto game, we need to define two more methods in class \ct{SBECell} to handle mouse events.
\needlines{3}
\numFiletreeMethodInput[mouseAction:]%
{A typical setter method.}%
{ListingSources/SBE-Quinto.package/SBECell.class/instance/mouseAction..st}

\Mthref{mouseAction:} does nothing more than set the cell's \ct{mouseAction} variable to the argument, and then answers the new value.
Any method that \emph{changes} the value of an instance variable in this way is called a \emph{setter method}; a method that \emph{answers} the current value of an instance variable is called a \emph{getter method}.
\seeindex{setter method}{accessor}
\seeindex{getter method}{accessor}

If you are used to getters and setters in other programming languages, you might expect these methods to be called \ct{setmouseAction} and \ct{getmouseAction}.
The \st convention is different.
A getter always has the same name as the variable it gets, and a setter is named similarly, but with a trailing ``\ct{:}'', hence \ct{mouseAction} and \ct{mouseAction:}.

Collectively, setters and getters are called \emphind{accessor} methods\cite{Klim96a}, and by convention they should be placed in the \protind{accessing} protocol.
In Smalltalk, \emph{all} instance variables are private to the object that owns them, so the only way for another object to read or write those variables in the Smalltalk language is through accessor methods like this one\footnote{%
	In fact, the instance variables can be accessed in subclasses too.%
}.

\dothis{Go to the class \ct{SBECell}, define \ct{SBECell>>>mouseAction:} and put it in the \prot{accessing} protocol.}

Finally, we need to define a method \ct{mouseUp:}; this will be called automatically by the GUI framework if the mouse button is released while the mouse is over this cell on the screen.

\numFiletreeMethodInput[sbecellmouseup]%
{An event handler.}%
{ListingSources/SBE-Quinto.package/SBECell.class/instance/mouseUp..st}
\cmindex{SBECell}{mouseUp:}

\dothis{Add the method \ct{SBECell>>>mouseUp:} and then \menu{categorize all uncategorized} methods.}
\index{method!categorize}

This method sends the message \ct{value} to the object stored in the instance variable \ct{mouseAction}.
Recall that in \ct{SBEGame>>>newCellAt: i at: j} we assigned the following code fragment to \ct{mouseAction}:

\ct{[self toggleNeighboursOfCellAt: i at: j ]}

\noindent
Sending the \ct{value} message causes this code fragment to be evaluated, and consequently, the state of the cells will toggle.

%=================================================================
\section{Let's try our code}

That's it:
The Quinto game is complete!

If you have followed all of the steps, you should be able to play the game, consisting of just 2 classes and 7 methods.

\dothis{In a workspace, type \ct{SBEGame new openInWorld} and \menu{do it}.}

The game will open, and you should be able to click on the cells and see how it works.

Well, so much for theory\ldots{}
When you click on a cell, a \emphind{notifier} window appears with an error message!
As depicted in \figref{quintoError}, it says \ct{MessageNotUnderstood: SBEGame>>>toggleState}.

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/Error.png' frame: #morphs building: [:helper |
	helper restoreMethods: {SBEGame >> #newCellAt:at:} after: [
		| game |
		SBEGame compile: ((SBEGame sourceCodeAt: #newCellAt:at:) asString
			lines allButLast joinSeparatedBy: String cr).
		game := SBEGame new.
		game openInWorld.
		helper
			runModal: [helper click: game]
			then: [
				helper world
					allMorphsDo: [:m | (m respondsTo: #updateFillStyle) ifTrue: [m updateFillStyle]];
					flag: #workaround. "Avoid to display all buttons as pressed.
						MorphicDebugger class>>#openOn:context:label:contents:fullView: schedules a deferred UI message for building the debugger. In the UI message, it reactivates the original current event, which is a mouseDown event in this context. During UI building, #updateFillStyle is sent to all buttons when their getStateSelector is set. Because of the current mouseDown event, #updateFillStyle will give a pressed look to any button that is under the cursor. As the buttons are not yet layouted properly during initialization, for some scale factors, all buttons initially appear under the cursor and are thus associated with an erroneous pressed look. It's hard to tell where this bug originates: in the debugger, which reuses the current event, or in the #updateFillStyle:, which does not check the mouseFocus of the current event. This workaround just updates the fill style of every button after the mouseDown event has been deactivated."
				game abandon]]
]
\end{ExecuteSmalltalkScript}
\begin{figure}[ht]
\ifluluelse
	{\centerline{\includegraphics[width=0.75\textwidth]{Error}}}
	{\centerline{\includegraphics[scale=0.7]{Error}}}
\caption{There is a bug in our game when a cell is clicked!
\label{fig:quintoError}}
\end{figure}

\noindent
What happened?
To find out, let's use one of Smalltalk's more powerful tools: the \ind{debugger}.

\dothis{Click on the \menu{debug} button in the notifier window.}
The debugger will appear.
In the upper part of the debugger window you can see the execution stack, showing all the active methods; selecting any one of them will show, in the middle pane, the Smalltalk code being executed in that method, with the part that triggered the error highlighted.

\dothis{Click on the line labelled \ct{SBEGame>>>toggleNeighboursOfCellAt:at:} (near the top).}
The debugger will show you the \ind{execution context} within this method where the error occurred (\figref{debugToggle}).

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/Debugger.png' frame: #morphs building: [:helper |
	helper restoreMethods: {SBEGame >> #newCellAt:at:} after: [
		| game stackList |
		SBEGame compile: ((SBEGame sourceCodeAt: #newCellAt:at:) asString
			lines allButLast joinSeparatedBy: String cr).
		game := SBEGame new.
		game openInWorld.
		helper
			runModal: [helper click: game]
			then: [
				helper hand dropMorphs.
				game abandon.
				stackList := helper listMorphIncludingMatch: '*toggleNeighboursOfCellAt:at:*' in: helper foregroundWindow.
				helper keyStroke: stackList key: Character arrowDown.
				helper foregroundWindow extent: 600 px @ 400 px]]
]
\end{ExecuteSmalltalkScript}
\begin{figure}[ht]
\ifluluelse
	{\centerline {\includegraphics[width=\textwidth]{Debugger}}}
	{\centerline {\includegraphics[scale=0.7]{Debugger}}}
\caption{The debugger, with the method \ct{toggleNeighboursOfCell:at:}  selected.
\label{fig:debugToggle}}
\end{figure}

At the bottom of the debugger are two small inspector windows.
On the left, you can inspect the object that is the receiver of the message that caused the selected method to execute, so you can look here to see the values of the instance variables.
On the right you can inspect an object that represents the currently executing method itself, so you can look here to see the values of the method's parameters and temporary variables.

Using the debugger, you can execute code step by step, inspect objects in parameters and local variables, evaluate code just as you can in a workspace, and, most surprisingly to those used to other debuggers, change the code while it is being debugged!
Some Smalltalkers program in the debugger almost all the time, rather than in the browser.
The advantage of this is that you see the method that you are writing as it will be executed, with real parameters in the actual execution context.

In this case, we can see in the first line of the top panel that the \ct{toggleState} message has been sent to an instance of \ct{SBEGame}, while it should clearly have been an instance of \lct{SBECell}.
We can also see this by selecting the cells variable in the lower-left pane in the debugger.
The problem is most likely with the initialization of the \ct{cells} matrix.
Browsing the code of \cmind{SBEGame}{initialize} shows that \ct{cells} is filled with the return values of \ct{newCellAt:at:}, but when we look at that method, we see that there is no return statement there!
By default, a method returns \ct{self}, which in the case of \ct{newCellAt:at:} is indeed an instance of \ct{SBEGame}.
\index{method!returning self}

\dothis{Close the debugger window.
	Add the expression ``\ct{^ cell}'' to the end of the method \ct{SBEGame>>>newCellAt:at:} so that it returns \ct{cell}.
	% It should now look as shown in \mthref{newCellAt:at:nobug}.}
	(See \mthref{newCellAt:at:nobug}.)}

\needlines{10}
\numFiletreeMethodInput[newCellAt:at:nobug]{Fixing the bug.}{ListingSources/SBE-Quinto.package/SBEGame.class/instance/newCellAt.at..st}
\cmindex{SBEGame}{newCellAt:at:}

\index{^@{$\uparrow$}|see{return}}

Often, you can fix the code directly in the debugger window and click \menu{Proceed} to continue running the application.
In our case, because the bug was in the initialization of an object, rather than in the method that failed, the easiest thing to do is to close the debugger window, destroy the running instance of the game (with the \subind{Morphic}{halo}), and create a new one.

\dothis{Do: \ct{SBEGame new openInWorld} again.}
Now the game should work properly.

%=================================================================
\section{Saving and sharing Smalltalk code}
\label{sec:Monticello}

Now that you have the Quinto game working, you probably want to save it somewhere so that you can share it with your friends.
Of course, you can save your whole \squeak image, and show off your first program by running it, but your friends probably have their own code in their images, and don't want to give that up to use your image.
What you need is a way of getting source code out of your \squeak image so that other programmers can bring it into theirs.
There is a variety of ways to do this, from ad-hoc sharing via exported files, to built-in version control systems like Monticello, or full tool support for Git.

The simplest way of doing this is by \emph{filing out} the code.
The yellow-button menu in the System Categories pane will give you the option to file out the whole of category \scat{SBE-Quinto}.
The resulting file is more or less human-readable, but is really intended for computers, not humans.
You can email this file to your friends, and they can file it into their own \squeak images using the file list browser.
\seeindex{saving code}{categories}
\seeindex{category!filing out}{file, filing out}
\seeindex{class!filing out}{file, filing out}
\seeindex{method!filing out}{file, filing out}
\index{file!filing out}

\dothis{Yellow-click on the \scat{SBE-Quinto} category and \menu{fileOut} the contents.}
You should now find a file called ``SBE-Quinto.st'' in the same folder on disk where your image is saved.
Have a look at this file with a text editor.

\dothis{Open a fresh \squeak image and drag the exported file onto the running Squeak.
Verify that the game now works in the new image.}
\seeindex{category!filing in}{file, filing in}
\seeindex{class!filing in}{file, filing in}
\seeindex{method!filing in}{file, filing in}
\index{file!filing in}

\subsection{Monticello packages}
Although fileouts are a convenient way of making a snapshot of the code you have written, they do not work well for long-running projects.
Just as most open-source projects find it much more convenient to maintain their code in a repository using \ind{Git}\footnote{\url{www.git-scm.com}} or \ind{Mercurial}\footnote{\url{www.mercurial-scm.org}}, so \squeak programmers find it more convenient to manage their code using \ind{Monticello} packages.
These packages are represented as files with names ending in \ct{.mcz}; they are actually zip-compressed bundles that contain the complete code of your \ind{package}.

Using the Monticello package browser, you can save packages to repositories on various types of servers, including FTP and HTTP servers; you can also just write the packages to a repository in a local file system directory.
A copy of your package is also always cached on your local hard-disk in the \emph{package-cache} folder.
Monticello lets you save multiple versions of your program, merge versions, go back to an old version, and browse the differences between versions.
In fact, Monticello is a distributed version control system just like Git; this means it allows developers to save their work on different places, not on a single repository.
\seeindex{package browser}{Monticello}

You can also send a \ct{.mcz} file by email.
The recipient will have to place it in her \emph{package-cache} folder; she will then be able to use Monticello to browse and load it.

\dothis{Open the Monticello browser by selecting \menu{World~\go{} open\,\ldots~\go{} Monticello browser}.}
In the right-hand pane of the browser (see \figref{monticello1}) is a list of Monticello repositories, which will include all of the repositories from which code has been loaded into the image that you are using.

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/MonticelloBrowser.png' frame: #morphs building: [:helper |
  MCWorkingCopyBrowser open
]
\end{ExecuteSmalltalkScript}
\begin{figure}[hbt]
\ifluluelse
	{\centerline {\includegraphics[width=\textwidth]{MonticelloBrowser}}}
	{\centerline {\includegraphics[scale=0.7]{MonticelloBrowser}}}
\caption{The Monticello browser.
\label{fig:monticello1}}
\end{figure}

At the top of the list in the Monticello browser is a repository in a local directory called the \emphind{package cache}, which caches copies of the packages that you have loaded or published over the network.
This local cache is really handy because it lets you keep your own local history; it also allows you to work in places where you do not have internet access, or where access is slow and you do not want to save to a remote repository frequently.


\subsection{Saving and loading code with Monticello.}
On the left-hand side of the Monticello browser is a list of packages that have a version loaded into the image; packages that have been modified since they were loaded are marked with an asterisk.
(These are sometimes referred to as \emph{\subind{package}{dirty} packages}.)
If you select a package, the list of repositories is restricted to just those repositories that contain a copy of the selected package.
\seeindex{*}{package, dirty}
\seeindex{dirty package}{package, dirty}

What is a package?
For now, you can think of a package as a group of class categories and protocols that share the same prefix.
Since we put all of the code for the Quinto game into the class category called \scat{SBE-Quinto}, we can refer to it as the \ct{SBE-Quinto} package.

\dothis{Add the \ct{SBE-Quinto} package to your Monticello browser using the \button{+Package} button and type \ct{SBE-Quinto}.}

\subsection{\ind{SqueakSource}: a sharing platform for Monticello.}
We think that the best way to save your code and share it is to create an account for your project on a SqueakSource server.
SqueakSource is like GitHub\footnote{\url{www.github.com}}:
It is a web front-end to an HTTP Monticello server that lets you manage your projects.
There is a public SqueakSource server at \url{http://www.squeaksource.com}, and a copy of the code related to our game is stored there at \url{http://www.squeaksource.com/QuintoExampleSBE.html}.
You can look at this project with a web browser, but it's a lot more productive to do so from inside \squeak, using the Monticello browser, which lets you manage your packages.

\dothis{Open a web browser to \url{www.squeaksource.com}.
Create an account for yourself and then create (\ie ``register'') a project for the Quinto game.}
SqueakSource will show you the information that you should use when adding a repository using the Monticello browser.

Once your project has been created on SqueakSource, you have to tell your \squeak system to use it.

\dothis{With the \ct{SBE-Quinto} package selected, click the \button{+Repository} button in the Monticello browser.}
You will see a list of the different available types of repositories; to add a SqueakSource repository select \menu{HTTP}.
You will be presented with a dialog in which you can provide the necessary information about the server.
You should copy the presented template to identify your SqueakSource project, paste it into Monticello, and supply your initials and password:

\needlines{5}
\begin{code}{}
MCHttpRepository
    location: 'http://www.squeaksource.com/!\emph{YourProject}!'
    user: '!\emph{yourInitials}!'
    password: '!\emph{yourPassword}!'
\end{code}

\noindent
If you provide empty initials and password strings, you can still load the project, but you will not be able to update it:

\needlines{5}
\begin{code}{}
MCHttpRepository
    location: 'http://www.squeaksource.com/!\emph{YourProject}!'
    user: ''
    password: ''
\end{code}

%You can then load the code in your image by selecting the version you want. You can browse the code without loading it, using the \button{Browse} button.
Once you have accepted this template, your new repository should be listed on the right-hand side of the Monticello browser.

\begin{ExecuteSmalltalkScript}
SBEScreenshotRecorder writeTo: './figures/BrowseRepository.png' frame: #morphs building: [:helper |
	| window packageList |
	helper mcCachePackages: #('SBE-Quinto') during: [
		helper hideProgressMorph.
		MCCacheRepository default morphicOpen.
		window := helper foregroundWindow.
		packageList := helper listMorphIncludingMatch: 'SBE-Quinto' in: window.
		window model versionSelection: 1]
]
\end{ExecuteSmalltalkScript}
\begin{figure}[h]
\ifluluelse
	{{\includegraphics[width=\textwidth]{BrowseRepository}}}
	{{\includegraphics[scale=0.7]{BrowseRepository}}}
\caption{Browsing a Monticello repository.
\label{fig:monticello3}}
\end{figure}

\dothis{Click on \button{Save} to save the first version of your Quinto game on SqueakSource.}

To load a package into your image, you must first select a particular version.
You can do this in the repository browser, which you can open using the \button{Open} button or the yellow-button menu.
Once you have selected a version, you can load it onto your image.

\dothis{Open the \ct{SBE-Quinto} repository you have just saved.}

Monticello has many more capabilities, which will be discussed in depth in \charef{env}.
%You can also look at the on-line documentation for Monticello at \url{http://www.wiresong.ca/Monticello/}.

%=================================================================
\section{Chapter summary}
In this chapter, you have seen how to create categories, classes, and methods.
You have seen how to use the system browser, the inspector, the debugger, and the Monticello browser.

\begin{itemize}
  \item Categories are groups of related classes.
  \item A new class is created by sending a message to its superclass.
  \item Protocols are groups of related methods.
  \item A new method is created or modified by editing its definition in the browser and then \emph{accepting} the changes.
  \item The inspector offers a simple, general-purpose GUI for inspecting and interacting with arbitrary objects.
  \item The system browser detects usage of undeclared methods and variables, and offers possible corrections.
  \item The \ct{initialize} method is automatically executed after an object is created in \squeak.
  You can put any initialization code there.
  \item The debugger provides a high-level GUI to inspect and modify the state of a running program.
  \item You can share source code \emph{filing out} a category.
  \item A better way to share code is to use Monticello to manage an external repository, for example, defined as a SqueakSource project.
\end{itemize}

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================
%=================================================================
%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End:
